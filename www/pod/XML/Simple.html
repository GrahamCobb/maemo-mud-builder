<head>
<!-- Generated by perlmod2www.pl -->
<title>
Simple documentation.
</title>
<link rel="stylesheet" type="text/css" href="../perl.css">
</head>
<body bgcolor="white">
<span id="modRootPath">XML</span>
<span id="modName">Simple</span>
<div id="sep"></div>
<a name="TOP" id="TOP"></a>
<table id="daArea" width="100%"><tr><td id="daEntry" ><a href="#SUMMARY">Summary</a></td><td id="daEntry" ><a href="#libs">Included libraries</a></td><td id="daEntry" ><a href="#vardefs">Package variables</a></td><td id="daEntry" ><a href="#SYNOPSIS">Synopsis</a></td><td id="daEntry" ><a href="#DESCRIPTION">Description</a></td><td id="daEntry" ><a href="#General">General documentation</a></td><td id="daEntry" ><a href="#Methods">Methods</a></td></tr></table>
<div id="sep"></div>
<div id="descTitle">Summary</div>
<div id="descArea"><B>XML::Simple</B> - Easy API to maintain XML (esp config files)</div>
<div id="sep"></div>
<a name="vardefs" id="vardefs"></a><div id="descTitle">Package variables</div>
<div id="descArea"><div id="libEntry"><div id="descSubTitle">Privates (from <b>"my"</b> definitions)</div>
</div>
<div id="libEntry"><span id="var">$DefXmlDecl</span> = <span id="perlFunc">qq</span><span id="dqStr">(&lt;?xml version='1.0' standalone='yes'?&gt;)</span></div>
<div id="libEntry"><span id="var">$StrictMode</span> = 0</div>
<div id="libEntry"><span id="var">@KnownOptIn</span> = <span id="perlFunc">qw</span><span id="braces">(</span>keyattr keeproot forcecontent contentkey noattr                        searchpath forcearray cache suppressempty parseropts                        grouptags nsexpand datahandler varattr variables                        normalisespace normalizespace valueattr<span id="braces">)</span></div>
<div id="libEntry"><span id="var">@KnownOptOut</span> = <span id="perlFunc">qw</span><span id="braces">(</span>keyattr keeproot contentkey noattr                        rootname xmldecl outputfile noescape suppressempty                        grouptags nsexpand handler noindent attrindent nosort                        valueattr numericescape<span id="braces">)</span></div>
<div id="libEntry"><span id="var">$DefRootName</span> = <span id="perlFunc">qq</span><span id="dqStr">(opt)</span></div>
<div id="libEntry"><span id="var">%MemCopyCache</span> = <span id="braces">(</span><span id="braces">)</span></div>
<div id="libEntry"><span id="var">$xmlns_ns</span> = <span id="sqStr">'http://www.w3.org/2000/xmlns/'</span></div>
<div id="libEntry"><span id="var">$bad_def_ns_jcn</span> = <span id="sqStr">'{'</span> . <span id="var">$xmlns_ns</span> . <span id="sqStr">'}'</span></div>
<div id="libEntry"><span id="var">@DefKeyAttr</span> = <span id="perlFunc">qw</span><span id="braces">(</span>name key id<span id="braces">)</span></div>
<div id="libEntry"><span id="var">$DefContentKey</span> = <span id="perlFunc">qq</span><span id="dqStr">(content)</span></div>
<div id="libEntry"><span id="var">%MemShareCache</span> = <span id="braces">(</span><span id="braces">)</span></div>
</div>
<div id="sep"></div>
<div id="descTitle">Included modules</div>
<div id="descArea"><div id="libEntry"><span id="use">Carp</span></div>
</div>
<div id="sep"></div>
<a name="libs" id="libs"></a>
<div id="descTitle">Inherit</div>
<div id="descArea"><span id="isa">Exporter</span> </div>
<div id="sep"></div>
<a name="SYNOPSIS" id="SYNOPSIS"></a>
<div id="descTitle">Synopsis</div>
<div id="descArea"><pre id="podParagraph">    use XML::Simple;

    my $ref = XMLin([<xml file or string>] [, <options>]);

    my $xml = XMLout($hashref [, <options>]);
</pre>Or the object oriented way:<br /><pre id="podParagraph">    require XML::Simple;

    my $xs = <B>XML::Simple</B>->new(options);

    my $ref = $xs->XMLin([<xml file or string>] [, <options>]);

    my $xml = $xs->XMLout($hashref [, <options>]);
</pre>(or see <a href="#_pod_"SAX SUPPORT"">"SAX SUPPORT"</a> for 'the SAX way').<br />To catch common errors:<br /><pre id="podParagraph">    use <B>XML::Simple</B> qw(:strict);
</pre>(see <a href="#_pod_"STRICT MODE"">"STRICT MODE"</a> for more details).
</div>
<div id="sep"></div>
<a name="DESCRIPTION" id="DESCRIPTION"></a>
<div id="descTitle">Description</div>
<div id="descArea">The <B>XML::Simple</B> module provides a simple API layer on top of an underlying XML<br />parsing module (either XML::Parser or one of the SAX2 parser modules).  Two<br />functions are exported: XMLin() and XMLout().  Note: you can explicity<br />request the lower case versions of the function names: xml_in() and<br />xml_out().<br />The simplest approach is to call these two functions directly, but an<br />optional object oriented interface (see <a href="#_pod_"OPTIONAL OO INTERFACE"">"OPTIONAL OO INTERFACE"</a> below)<br />allows them to be called as methods of an <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> object.  The object<br />interface can also be used at either end of a SAX pipeline.
Parses XML formatted data and returns a reference to a data structure which<br />contains the same information in a more readily accessible form.  (Skip<br />down to <a href="#_pod_"EXAMPLES"">"EXAMPLES"</a> below, for more sample code).<br />XMLin() accepts an optional XML specifier followed by zero or more 'name =&gt;<br />value' option pairs.  The XML specifier can be one of the following:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;A filename</div>&nbsp;&nbsp;&nbsp;&nbsp;If the filename contains no directory components XMLin() will look for the<br />file in each directory in the SearchPath (see <a href="#_pod_"OPTIONS"">"OPTIONS"</a> below) or in the<br />current directory if the SearchPath option is not defined.  eg:<br /><pre id="podParagraph">  $ref = XMLin('/etc/params.xml');
</pre>&nbsp;&nbsp;&nbsp;&nbsp;Note, the filename '-' can be used to parse from STDIN.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;undef</div>&nbsp;&nbsp;&nbsp;&nbsp;If there is no XML specifier, XMLin() will check the script directory and<br />each of the SearchPath directories for a file with the same name as the script<br />but with the extension '.xml'.  Note: if you wish to specify options, you<br />must specify the value 'undef'.  eg:<br /><pre id="podParagraph">  $ref = XMLin(undef, ForceArray => 1);
</pre><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;A string of XML</div>&nbsp;&nbsp;&nbsp;&nbsp;A string containing XML (recognised by the presence of '&lt;' and '&gt;' characters)<br />will be parsed directly.  eg:<br /><pre id="podParagraph">  $ref = XMLin('<opt username="bob" password="flurp" />');
</pre><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;An IO::Handle object</div>&nbsp;&nbsp;&nbsp;&nbsp;An IO::Handle object will be read to EOF and its contents parsed. eg:<br /><pre id="podParagraph">  $fh = IO::File->new('/etc/params.xml');
  $ref = XMLin($fh);
</pre>
Takes a data structure (generally a hashref) and returns an XML encoding of<br />that structure.  If the resulting XML is parsed using XMLin(), it should<br />return a data structure equivalent to the original (see caveats below). <br />The XMLout() function can also be used to output the XML as SAX events<br />see the Handler option and <a href="#_pod_"SAX SUPPORT"">"SAX SUPPORT"</a> for more details).<br />When translating hashes to XML, hash keys which have a leading '-' will be<br />silently skipped.  This is the approved method for marking elements of a<br />data structure which should be ignored by XMLout.  (Note: If these items<br />were not skipped the key names would be emitted as element or attribute names<br />with a leading '-' which would not be valid XML).
Some care is required in creating data structures which will be passed to<br />XMLout().  Hash keys from the data structure will be encoded as either XML<br />element names or attribute names.  Therefore, you should use hash key names <br />which conform to the relatively strict XML naming rules:<br />Names in XML must begin with a letter.  The remaining characters may be<br />letters, digits, hyphens (-), underscores (_) or full stops (.).  It is also<br />allowable to include one colon (:) in an element name but this should only be<br />used when working with namespaces (<a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> can only usefully work with<br />namespaces when teamed with a SAX Parser).<br />You can use other punctuation characters in hash values (just not in hash<br />keys) however <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> does not support dumping binary data.<br />If you break these rules, the current implementation of XMLout() will <br />simply emit non-compliant XML which will be rejected if you try to read it<br />back in.  (A later version of <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> might take a more proactive<br />approach).<br />Note also that although you can nest hashes and arrays to arbitrary levels,<br />circular data structures are not supported and will cause XMLout() to die.<br />If you wish to 'round-trip' arbitrary data structures from Perl to XML and back <br />to Perl, then you should probably disable array folding (using the KeyAttr<br />option) both with XMLout() and with XMLin().  If you still don't get the <br />expected results, you may prefer to use <a href="#_pod_XML::Dumper">XML::Dumper</a> which is designed for<br />exactly that purpose.<br />Refer to <a href="#_pod_"WHERE TO FROM HERE?"">"WHERE TO FROM HERE?"</a> if XMLout() is too simple for your needs.
</div>
<div id="sep"></div>
<a name="Methods" id="Methods"></a>
<div id="descTitle">Methods</div>
<table id="methIndArea" width="100%" cellspacing="0"><tr><td id="methIndEntry">XMLin</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE1">Code</a></td></tr>
<tr><td id="methIndEntry">XMLout</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE2">Code</a></td></tr>
<tr><td id="methIndEntry">_get_object</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE3">Code</a></td></tr>
<tr><td id="methIndEntry">array_to_hash</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE4">Code</a></td></tr>
<tr><td id="methIndEntry">build_tree</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE5">Code</a></td></tr>
<tr><td id="methIndEntry">build_tree_xml_parser</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE6">Code</a></td></tr>
<tr><td id="methIndEntry">cache_read_memcopy</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE7">Code</a></td></tr>
<tr><td id="methIndEntry">cache_read_memshare</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE8">Code</a></td></tr>
<tr><td id="methIndEntry">cache_read_storable</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE9">Code</a></td></tr>
<tr><td id="methIndEntry">cache_write_memcopy</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE10">Code</a></td></tr>
<tr><td id="methIndEntry">cache_write_memshare</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE11">Code</a></td></tr>
<tr><td id="methIndEntry">cache_write_storable</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE12">Code</a></td></tr>
<tr><td id="methIndEntry">characters</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE13">Code</a></td></tr>
<tr><td id="methIndEntry">collapse</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE14">Code</a></td></tr>
<tr><td id="methIndEntry">collapse_content</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE15">Code</a></td></tr>
<tr><td id="methIndEntry">copy_hash</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE16">Code</a></td></tr>
<tr><td id="methIndEntry">end_document</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE17">Code</a></td></tr>
<tr><td id="methIndEntry">end_element</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE18">Code</a></td></tr>
<tr><td id="methIndEntry">escape_value</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE19">Code</a></td></tr>
<tr><td id="methIndEntry">find_xml_file</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE20">Code</a></td></tr>
<tr><td id="methIndEntry">get_var</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE21">Code</a></td></tr>
<tr><td id="methIndEntry">handle_options</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE22">Code</a></td></tr>
<tr><td id="methIndEntry">hash_to_array</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE23">Code</a></td></tr>
<tr><td id="methIndEntry">import</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE24">Code</a></td></tr>
<tr><td id="methIndEntry">new</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE25">Code</a></td></tr>
<tr><td id="methIndEntry">new_hashref</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE26">Code</a></td></tr>
<tr><td id="methIndEntry">normalise_space</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE27">Code</a></td></tr>
<tr><td id="methIndEntry">numeric_escape</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE28">Code</a></td></tr>
<tr><td id="methIndEntry">set_var</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE29">Code</a></td></tr>
<tr><td id="methIndEntry">sorted_keys</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE30">Code</a></td></tr>
<tr><td id="methIndEntry">start_document</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE31">Code</a></td></tr>
<tr><td id="methIndEntry">start_element</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE32">Code</a></td></tr>
<tr><td id="methIndEntry">storable_filename</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE33">Code</a></td></tr>
<tr><td id="methIndEntry">value_to_xml</td><td id="methIndEntry"><div id="error">No description</div></td><td id="methIndEntry"><a href="#CODE34">Code</a></td></tr>
</table>
<div id="sep"></div>
<a name="MethDesc" id="MethDesc"></a>
<div id="mainTitle">Methods description</div>
<div id="sep"></div>
<div id="error">None available.</div>
<div id="sep"></div>
<a name="MethCode" id="MethCode"></a>
<div id="mainTitle">Methods code</div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE1" id="CODE1"></a>XMLin</td><td >description</td><td >prev</td><td ><a href="#CODE2">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">XMLin</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = &amp;_get_object;      <span id="comment"># note, @_ is passed implicitly</span><br />
  <span id="perlKey">my</span> <span id="var">$string</span> = <span id="perlFunc">shift</span>;

  <span id="var">$self</span>-&gt;<span id="method">handle_options</span><span id="braces">(</span><span id="sqStr">'in'</span>, <span id="var">@_</span><span id="braces">)</span>;


  <span id="comment"># If no XML or filename supplied, look for scriptname.xml in script directory</span><br />
  <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span><span id="braces">)</span>  <span id="braces">{</span>
    
    <span id="comment"># Translate scriptname[.suffix] to scriptname.xml</span><br />
    <span id="perlKey">require</span> <span id="module">File::Basename</span>;

    <span id="perlKey">my</span><span id="braces">(</span><span id="var">$ScriptName</span>, <span id="var">$ScriptDir</span>, <span id="var">$Extension</span><span id="braces">)</span> =
      <span id="module">File::Basename</span>::<span id="method">fileparse</span><span id="braces">(</span><span id="var">$0</span>, <span id="sqStr">'\.[^\.]+'</span><span id="braces">)</span>;

    <span id="var">$string</span> = <span id="var">$ScriptName</span> . <span id="sqStr">'.xml'</span>;


    <span id="comment"># Add script directory to searchpath</span><br />    
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$ScriptDir</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlFunc">unshift</span><span id="braces">(</span>@<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span><span id="braces">}</span>, <span id="var">$ScriptDir</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  

  <span id="comment"># Are we parsing from a file?  If so, is there a valid cache available?</span><br />
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$filename</span>, <span id="var">$scheme</span><span id="braces">)</span>;
  <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$string</span> =~ <span id="regExp">m{&lt;.*?&gt;}s</span>  or  <span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span>  or  <span id="var">$string</span> <span id="perlKey">eq</span> <span id="sqStr">'-'</span><span id="braces">)</span> <span id="braces">{</span>

    <span id="perlKey">require</span> <span id="module">File::Basename</span>;
    <span id="perlKey">require</span> <span id="module">File::Spec</span>;

    <span id="var">$filename</span> = <span id="var">$self</span>-&gt;<span id="method">find_xml_file</span><span id="braces">(</span><span id="var">$string</span>, @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span>;

    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">foreach</span> <span id="var">$scheme</span> <span id="braces">(</span>@<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">my</span> <span id="var">$method</span> = <span id="sqStr">'cache_read_'</span> . <span id="var">$scheme</span>;
        <span id="perlKey">my</span> <span id="var">$opt</span> = <span id="var">$self</span>-&gt;<span id="var">$method</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span>;
        <span id="perlKey">return</span><span id="braces">(</span><span id="var">$opt</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span><span id="braces">)</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">)</span>;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$string</span> <span id="perlKey">eq</span> <span id="sqStr">'-'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="comment"># Read from standard input</span><br />
      <span id="perlKey">local</span><span id="braces">(</span>$/<span id="braces">)</span> = <span id="perlFunc">undef</span>;
      <span id="var">$string</span> = &lt;STDIN&gt;;
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Parsing is required, so let's get on with it</span><br />
  <span id="perlKey">my</span> <span id="var">$tree</span> =  <span id="var">$self</span>-&gt;<span id="method">build_tree</span><span id="braces">(</span><span id="var">$filename</span>, <span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span> ? <span id="var">$string</span> :\$ string<span id="braces">)</span>;
  <span id="perlFunc">undef</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span>;

  <span id="comment"># Now work some magic on the resulting parse tree</span><br />
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keeproot<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$ref</span> = <span id="var">$self</span>-&gt;<span id="method">collapse</span><span id="braces">(</span><span id="braces">{</span><span id="braces">}</span>, @$tree<span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$ref</span> = <span id="var">$self</span>-&gt;<span id="method">collapse</span><span id="braces">(</span>@<span id="braces">{</span><span id="var">$tree</span>-&gt;<span id="braces">[</span>1<span id="braces">]</span><span id="braces">}</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">my</span> <span id="var">$method</span> = <span id="sqStr">'cache_write_'</span> . <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span>;
    <span id="var">$self</span>-&gt;<span id="var">$method</span><span id="braces">(</span><span id="var">$ref</span>, <span id="var">$filename</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE2" id="CODE2"></a>XMLout</td><td >description</td><td ><a href="#CODE1">prev</a></td><td ><a href="#CODE3">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">XMLout</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = &amp;_get_object;      <span id="comment"># note, @_ is passed implicitly</span><br />
  croak <span id="dqStr">"XMLout() requires at least one argument"</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">@_</span><span id="braces">)</span>;
  <span id="perlKey">my</span> <span id="var">$ref</span> = <span id="perlFunc">shift</span>;

  <span id="var">$self</span>-&gt;<span id="method">handle_options</span><span id="braces">(</span><span id="sqStr">'out'</span>, <span id="var">@_</span><span id="braces">)</span>;


  <span id="comment"># If namespace expansion is set, XML::NamespaceSupport is required</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nsexpand<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">require</span> <span id="module">XML::NamespaceSupport</span>;
    <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span> = <span id="module">XML::NamespaceSupport</span>-&gt;<span id="perlKey">new</span><span id="braces">(</span><span id="braces">)</span>;
    <span id="var">$self</span>-&gt;<span id="braces">{</span>ns_prefix<span id="braces">}</span> = <span id="sqStr">'aaa'</span>;
  <span id="braces">}</span>


  <span id="comment"># Wrap top level arrayref in a hash</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$ref</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$ref</span> = <span id="braces">{</span> anon =&gt; <span id="var">$ref</span> <span id="braces">}</span>;
  <span id="braces">}</span>


  <span id="comment"># Extract rootname from top level hash if keeproot enabled</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keeproot<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">my</span><span id="braces">(</span><span id="var">@keys</span><span id="braces">)</span> = <span id="perlFunc">keys</span><span id="braces">(</span>%$<span id="perlFunc">ref</span><span id="braces">)</span>;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">@keys</span> == 1<span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$ref</span> = <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$keys</span><span id="braces">[</span>0<span id="braces">]</span><span id="braces">}</span>;
      <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span> = <span id="var">$keys</span><span id="braces">[</span>0<span id="braces">]</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  
  <span id="comment"># Ensure there are no top level attributes if we're not adding root elements</span><br />
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span> <span id="perlKey">eq</span> <span id="sqStr">''</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$ref</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">$refsave</span> = <span id="var">$ref</span>;
      <span id="var">$ref</span> = <span id="braces">{</span><span id="braces">}</span>;
      <span id="perlKey">foreach</span> <span id="braces">(</span><span id="perlFunc">keys</span><span id="braces">(</span>%$refsave<span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$refsave</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span> = <span id="var">$refsave</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span>;
        <span id="braces">}</span>
        <span id="perlKey">else</span> <span id="braces">{</span>
          <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span> = <span id="braces">[</span> <span id="var">$refsave</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span> <span id="braces">]</span>;
        <span id="braces">}</span>
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Encode the hashref and write to file if necessary</span><br />
  <span id="var">$self</span>-&gt;<span id="braces">{</span>_ancestors<span id="braces">}</span> = <span id="braces">[</span><span id="braces">]</span>;
  <span id="perlKey">my</span> <span id="var">$xml</span> = <span id="var">$self</span>-&gt;<span id="method">value_to_xml</span><span id="braces">(</span><span id="var">$ref</span>, <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span>, <span id="sqStr">''</span><span id="braces">)</span>;
  <span id="perlFunc">delete</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>_ancestors<span id="braces">}</span>;

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>xmldecl<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$xml</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>xmldecl<span id="braces">}</span> . <span id="dqStr">"\n"</span> . <span id="var">$xml</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>outputfile<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>outputfile<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">$fh</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>outputfile<span id="braces">}</span>;
      <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$fh</span>, <span id="sqStr">'GLOB'</span><span id="braces">)</span> and !<span id="module">UNIVERSAL</span>::<span id="method">can</span><span id="braces">(</span><span id="var">$fh</span>, <span id="sqStr">'print'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">eval</span> <span id="braces">{</span> <span id="perlKey">require</span> <span id="module">IO::Handle</span>; <span id="braces">}</span>;
        croak $@ <span id="perlKey">if</span> $@;
      <span id="braces">}</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="var">$fh</span>-&gt;<span id="perlFunc">print</span><span id="braces">(</span><span id="var">$xml</span><span id="braces">)</span><span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="perlKey">local</span><span id="braces">(</span>*OUT<span id="braces">)</span>;
      <span id="perlFunc">open</span><span id="braces">(</span>OUT, <span id="sqStr">'&gt;'</span>, <span id="dqStr">"<span id="var">$self</span>-&gt;{opt}-&gt;{outputfile}"</span><span id="braces">)</span> ||
        croak <span id="dqStr">"open(<span id="var">$self</span>-&gt;{opt}-&gt;{outputfile}): $!"</span>;
      <span id="perlFunc">binmode</span><span id="braces">(</span>OUT, <span id="sqStr">':utf8'</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span>$<span id="braces">]</span> &gt;= 5.008<span id="braces">)</span>;
      <span id="perlFunc">print</span> OUT <span id="var">$xml</span> || croak <span id="dqStr">"print: $!"</span>;
      <span id="perlFunc">close</span><span id="braces">(</span>OUT<span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>handler<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">require</span> <span id="module">XML::SAX</span>;
    <span id="perlKey">my</span> <span id="var">$sp</span> = <span id="module">XML::SAX::ParserFactory</span>-&gt;<span id="method">parser</span><span id="braces">(</span>
               Handler =&gt; <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>handler<span id="braces">}</span>
             <span id="braces">)</span>;
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$sp</span>-&gt;<span id="method">parse_string</span><span id="braces">(</span><span id="var">$xml</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$xml</span><span id="braces">)</span>;
  <span id="braces">}</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE3" id="CODE3"></a>_get_object</td><td >description</td><td ><a href="#CODE2">prev</a></td><td ><a href="#CODE4">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="privSubName">_get_object</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$_</span><span id="braces">[</span>0<span id="braces">]</span>  and  <span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$_</span><span id="braces">[</span>0<span id="braces">]</span>, <span id="sqStr">'XML::Simple'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$self</span> = <span id="perlFunc">shift</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$self</span> = <span id="module"><a href="Simple.html">XML::Simple</a></span>-&gt;<span id="perlKey">new</span><span id="braces">(</span><span id="braces">)</span>;
  <span id="braces">}</span>
  
  <span id="perlKey">return</span> <span id="var">$self</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE4" id="CODE4"></a>array_to_hash</td><td >description</td><td ><a href="#CODE3">prev</a></td><td ><a href="#CODE5">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">array_to_hash</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>     = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$name</span>     = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$arrayref</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">my</span> <span id="var">$hashref</span>  = <span id="var">$self</span>-&gt;<span id="method">new_hashref</span>;

  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$i</span>, <span id="var">$key</span>, <span id="var">$val</span>, <span id="var">$flag</span><span id="braces">)</span>;


  <span id="comment"># Handle keyattr =&gt; { .... }</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;
    <span id="braces">(</span><span id="var">$key</span>, <span id="var">$flag</span><span id="braces">)</span> = @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span><span id="braces">}</span>;
    <span id="perlKey">for</span><span id="braces">(</span><span id="var">$i</span> = 0; <span id="var">$i</span> &lt; @$arrayref; <span id="var">$i</span>++<span id="braces">)</span>  <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span> and
         <span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span>
      <span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$val</span> = <span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>;
        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$StrictMode</span><span id="braces">)</span> <span id="braces">{</span>
            croak <span id="dqStr">"&lt;<span id="var">$name</span>&gt; element has non-scalar '$key' key attribute"</span>;
          <span id="braces">}</span>
          <span id="perlKey">if</span><span id="braces">(</span>$^W<span id="braces">)</span> <span id="braces">{</span>
            carp <span id="dqStr">"Warning: &lt;<span id="var">$name</span>&gt; element has non-scalar '$key' key attribute"</span>;
          <span id="braces">}</span>
          <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span>;
        <span id="braces">}</span>
        <span id="var">$val</span> = <span id="var">$self</span>-&gt;<span id="method">normalise_space</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> == 1<span id="braces">)</span>;
        <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span> = <span id="braces">{</span> %<span id="braces">{</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span><span id="braces">}</span> <span id="braces">}</span>;
        <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span>-&gt;<span id="braces">{</span><span id="dqStr">"-<span id="var">$key</span>"</span><span id="braces">}</span> = <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$flag</span> <span id="perlKey">eq</span> <span id="sqStr">'-'</span><span id="braces">)</span>;
        <span id="perlFunc">delete</span> <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$flag</span> <span id="perlKey">eq</span> <span id="sqStr">'+'</span><span id="braces">)</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        croak <span id="dqStr">"&lt;<span id="var">$name</span>&gt; element has no '$key' key attribute"</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$StrictMode</span><span id="braces">)</span>;
        carp <span id="dqStr">"Warning: &lt;<span id="var">$name</span>&gt; element has no '$key' key attribute"</span> <span id="perlKey">if</span><span id="braces">(</span>$^W<span id="braces">)</span>;
        <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Or assume keyattr =&gt; [ .... ]</span><br />
  <span id="perlKey">else</span> <span id="braces">{</span>
    ELEMENT: <span id="perlKey">for</span><span id="braces">(</span><span id="var">$i</span> = 0; <span id="var">$i</span> &lt; @$arrayref; <span id="var">$i</span>++<span id="braces">)</span>  <span id="braces">{</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span>;

      <span id="perlKey">foreach</span> <span id="var">$key</span> <span id="braces">(</span>@<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>  <span id="braces">{</span>
          <span id="var">$val</span> = <span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>;
          <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span><span id="braces">)</span>;
          <span id="var">$val</span> = <span id="var">$self</span>-&gt;<span id="method">normalise_space</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>
            <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> == 1<span id="braces">)</span>;
          <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span> = <span id="braces">{</span> %<span id="braces">{</span><span id="var">$arrayref</span>-&gt;<span id="braces">[</span><span id="var">$i</span><span id="braces">]</span><span id="braces">}</span> <span id="braces">}</span>;
          <span id="perlFunc">delete</span> <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$val</span><span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>;
          <span id="perlKey">next</span> ELEMENT;
        <span id="braces">}</span>
      <span id="braces">}</span>

      <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span>;    <span id="comment"># No keyfield matched</span><br />    <span id="braces">}</span>
  <span id="braces">}</span>
  
  <span id="comment"># collapse any hashes which now only have a 'content' key</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>collapseagain<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$hashref</span> = <span id="var">$self</span>-&gt;<span id="method">collapse_content</span><span id="braces">(</span><span id="var">$hashref</span><span id="braces">)</span>;
  <span id="braces">}</span>
 
  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$hashref</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE5" id="CODE5"></a>build_tree</td><td >description</td><td ><a href="#CODE4">prev</a></td><td ><a href="#CODE6">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">build_tree</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>     = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$filename</span> = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$string</span>   = <span id="perlFunc">shift</span>;


  <span id="perlKey">my</span> <span id="var">$preferred_parser</span> = <span id="var">$PREFERRED_PARSER</span>;
  <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$preferred_parser</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$preferred_parser</span> = <span id="var">$ENV</span><span id="braces">{</span>XML_SIMPLE_PREFERRED_PARSER<span id="braces">}</span> || <span id="sqStr">''</span>;
  <span id="braces">}</span>
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$preferred_parser</span> <span id="perlKey">eq</span> <span id="sqStr">'XML::Parser'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="method">build_tree_xml_parser</span><span id="braces">(</span><span id="var">$filename</span>, <span id="var">$string</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">eval</span> <span id="braces">{</span> <span id="perlKey">require</span> <span id="module">XML::SAX</span>; <span id="braces">}</span>;      <span id="comment"># We didn't need it until now</span><br />  <span id="perlKey">if</span><span id="braces">(</span>$@<span id="braces">)</span> <span id="braces">{</span>                         <span id="comment"># No XML::SAX - fall back to XML::Parser</span><br />    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$preferred_parser</span><span id="braces">)</span> <span id="braces">{</span>        <span id="comment"># unless a SAX parser was expressly requested</span><br />      croak <span id="dqStr">"XMLin() could not load XML::SAX"</span>;
    <span id="braces">}</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="method">build_tree_xml_parser</span><span id="braces">(</span><span id="var">$filename</span>, <span id="var">$string</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="var">$XML</span>::<span id="module">SAX::ParserPackage</span> = <span id="var">$preferred_parser</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$preferred_parser</span><span id="braces">)</span>;

  <span id="perlKey">my</span> <span id="var">$sp</span> = <span id="module">XML::SAX::ParserFactory</span>-&gt;<span id="method">parser</span><span id="braces">(</span>Handler =&gt; <span id="var">$self</span><span id="braces">)</span>;
  
  <span id="var">$self</span>-&gt;<span id="braces">{</span>nocollapse<span id="braces">}</span> = 1;
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$tree</span> = <span id="var">$sp</span>-&gt;<span id="method">parse_uri</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span> &amp;&amp; <span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span> <span id="perlKey">ne</span> <span id="sqStr">'SCALAR'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$tree</span> = <span id="var">$sp</span>-&gt;<span id="method">parse_file</span><span id="braces">(</span><span id="var">$string</span><span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="var">$tree</span> = <span id="var">$sp</span>-&gt;<span id="method">parse_string</span><span id="braces">(</span>$$string<span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE6" id="CODE6"></a>build_tree_xml_parser</td><td >description</td><td ><a href="#CODE5">prev</a></td><td ><a href="#CODE7">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">build_tree_xml_parser</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>     = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$filename</span> = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$string</span>   = <span id="perlFunc">shift</span>;


  <span id="perlKey">eval</span> <span id="braces">{</span>
    <span id="perlKey">local</span><span id="braces">(</span>$^W<span id="braces">)</span> = 0;      <span id="comment"># Suppress warning from Expat.pm re File::Spec::load()</span><br />    <span id="perlKey">require</span> <span id="module">XML::Parser</span>; <span id="comment"># We didn't need it until now</span><br />  <span id="braces">}</span>;
  <span id="perlKey">if</span><span id="braces">(</span>$@<span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"XMLin() requires either XML::SAX or XML::Parser"</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nsexpand<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    carp <span id="dqStr">"'nsexpand' option requires XML::SAX"</span>;
  <span id="braces">}</span>

  <span id="perlKey">my</span> <span id="var">$xp</span> = <span id="module">XML::Parser</span>-&gt;<span id="perlKey">new</span><span id="braces">(</span>Style =&gt; <span id="sqStr">'Tree'</span>, @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>parseropts<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span>;
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="comment"># $tree = $xp-&gt;parsefile($filename);  # Changed due to prob w/mod_perl</span><br />    <span id="perlKey">local</span><span id="braces">(</span>*XML_FILE<span id="braces">)</span>;
    <span id="perlFunc">open</span><span id="braces">(</span>XML_FILE, <span id="sqStr">'&lt;'</span>, <span id="var">$filename</span><span id="braces">)</span> || croak <span id="perlFunc">qq</span><span id="dqStr">(<span id="var">$filename</span> - $!)</span>;
    <span id="var">$tree</span> = <span id="var">$xp</span>-&gt;<span id="method">parse</span><span id="braces">(</span>*XML_FILE<span id="braces">)</span>;
    <span id="perlFunc">close</span><span id="braces">(</span>XML_FILE<span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$tree</span> = <span id="var">$xp</span>-&gt;<span id="method">parse</span><span id="braces">(</span>$$string<span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE7" id="CODE7"></a>cache_read_memcopy</td><td >description</td><td ><a href="#CODE6">prev</a></td><td ><a href="#CODE8">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_read_memcopy</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;
  
  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$MemCopyCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span><span id="braces">)</span>;
  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$MemCopyCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span> &gt; <span id="braces">(</span><span id="perlFunc">stat</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span><span id="braces">)</span><span id="braces">[</span>9<span id="braces">]</span><span id="braces">)</span>;

  <span id="perlKey">return</span><span id="braces">(</span><span id="module">Storable</span>::<span id="method">dclone</span><span id="braces">(</span><span id="var">$MemCopyCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span>-&gt;<span id="braces">[</span>1<span id="braces">]</span><span id="braces">)</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE8" id="CODE8"></a>cache_read_memshare</td><td >description</td><td ><a href="#CODE7">prev</a></td><td ><a href="#CODE9">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_read_memshare</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;
  
  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$MemShareCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span><span id="braces">)</span>;
  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$MemShareCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span> &gt; <span id="braces">(</span><span id="perlFunc">stat</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span><span id="braces">)</span><span id="braces">[</span>9<span id="braces">]</span><span id="braces">)</span>;

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$MemShareCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span>-&gt;<span id="braces">[</span>1<span id="braces">]</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE9" id="CODE9"></a>cache_read_storable</td><td >description</td><td ><a href="#CODE8">prev</a></td><td ><a href="#CODE10">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_read_storable</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;
  
  <span id="perlKey">my</span> <span id="var">$cachefile</span> = <span id="var">$self</span>-&gt;<span id="method">storable_filename</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span>;

  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span>-r <span id="var">$cachefile</span><span id="braces">)</span>;
  <span id="perlKey">return</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="braces">(</span><span id="perlFunc">stat</span><span id="braces">(</span><span id="var">$cachefile</span><span id="braces">)</span><span id="braces">)</span><span id="braces">[</span>9<span id="braces">]</span> &gt; <span id="braces">(</span><span id="perlFunc">stat</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span><span id="braces">)</span><span id="braces">[</span>9<span id="braces">]</span><span id="braces">)</span>;

  <span id="perlKey">require</span> Storable;           <span id="comment"># We didn't need it until now</span><br />  
  <span id="perlKey">if</span> <span id="braces">(</span><span id="sqStr">'VMS'</span> <span id="perlKey">eq</span> $^O<span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="module">Storable</span>::<span id="method">retrieve</span><span id="braces">(</span><span id="var">$cachefile</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="module">Storable</span>::<span id="method">lock_retrieve</span><span id="braces">(</span><span id="var">$cachefile</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE10" id="CODE10"></a>cache_write_memcopy</td><td >description</td><td ><a href="#CODE9">prev</a></td><td ><a href="#CODE11">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_write_memcopy</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$data</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">require</span> Storable;           <span id="comment"># We didn't need it until now</span><br />  
  <span id="var">$MemCopyCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span> = <span id="braces">[</span><span id="perlFunc">time</span><span id="braces">(</span><span id="braces">)</span>, <span id="module">Storable</span>::<span id="method">dclone</span><span id="braces">(</span><span id="var">$data</span><span id="braces">)</span><span id="braces">]</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE11" id="CODE11"></a>cache_write_memshare</td><td >description</td><td ><a href="#CODE10">prev</a></td><td ><a href="#CODE12">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_write_memshare</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$data</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="var">$MemShareCache</span><span id="braces">{</span><span id="var">$filename</span><span id="braces">}</span> = <span id="braces">[</span><span id="perlFunc">time</span><span id="braces">(</span><span id="braces">)</span>, <span id="var">$data</span><span id="braces">]</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE12" id="CODE12"></a>cache_write_storable</td><td >description</td><td ><a href="#CODE11">prev</a></td><td ><a href="#CODE13">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">cache_write_storable</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$data</span>, <span id="var">$filename</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">my</span> <span id="var">$cachefile</span> = <span id="var">$self</span>-&gt;<span id="method">storable_filename</span><span id="braces">(</span><span id="var">$filename</span><span id="braces">)</span>;

  <span id="perlKey">require</span> Storable;           <span id="comment"># We didn't need it until now</span><br />
  <span id="perlKey">if</span> <span id="braces">(</span><span id="sqStr">'VMS'</span> <span id="perlKey">eq</span> $^O<span id="braces">)</span> <span id="braces">{</span>
    <span id="module">Storable</span>::<span id="method">nstore</span><span id="braces">(</span><span id="var">$data</span>, <span id="var">$cachefile</span><span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="comment"># If the following line fails for you, your Storable.pm is old - upgrade</span><br />    <span id="module">Storable</span>::<span id="method">lock_nstore</span><span id="braces">(</span><span id="var">$data</span>, <span id="var">$cachefile</span><span id="braces">)</span>;
  <span id="braces">}</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE13" id="CODE13"></a>characters</td><td >description</td><td ><a href="#CODE12">prev</a></td><td ><a href="#CODE14">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">characters</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>  = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$chars</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">my</span> <span id="var">$text</span>  = <span id="var">$chars</span>-&gt;<span id="braces">{</span>Data<span id="braces">}</span>;
  <span id="perlKey">my</span> <span id="var">$clist</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span>;
  <span id="perlKey">my</span> <span id="var">$pos</span> = $#$clist;
  
  <span id="perlKey">if</span> <span id="braces">(</span><span id="var">$pos</span> &gt; 0 and <span id="var">$clist</span>-&gt;<span id="braces">[</span><span id="var">$pos</span> - 1<span id="braces">]</span> <span id="perlKey">eq</span> <span id="sqStr">'0'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$clist</span>-&gt;<span id="braces">[</span><span id="var">$pos</span><span id="braces">]</span> .= <span id="var">$text</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlFunc">push</span> @$clist, 0 =&gt; <span id="var">$text</span>;
  <span id="braces">}</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE14" id="CODE14"></a>collapse</td><td >description</td><td ><a href="#CODE13">prev</a></td><td ><a href="#CODE15">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">collapse</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;


  <span id="comment"># Start with the hash of attributes</span><br />  
  <span id="perlKey">my</span> <span id="var">$attr</span>  = <span id="perlFunc">shift</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>                    <span id="comment"># Discard if 'noattr' set</span><br />    <span id="var">$attr</span> = <span id="braces">{</span><span id="braces">}</span>;
  <span id="braces">}</span>
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> == 2<span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$value</span><span id="braces">)</span> = <span id="perlFunc">each</span> %$attr<span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="var">$self</span>-&gt;<span id="method">normalise_space</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Do variable substitutions</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlKey">my</span> <span id="var">$var</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span><span id="braces">(</span>%$attr<span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$val</span> =~ <span id="regExp">s{\$\{([\w.]+)\}}{ $self-&gt;get_var($1) }ge</span>;
      <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="var">$val</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Roll up 'value' attributes (but only if no nested elements)</span><br />
  <span id="perlKey">if</span><span id="braces">(</span>!<span id="var">@_</span>  and  <span id="perlFunc">keys</span> %$attr == 1<span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">my</span><span id="braces">(</span><span id="var">$k</span><span id="braces">)</span> = <span id="perlFunc">keys</span> %$attr;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattrlist<span id="braces">}</span>  and <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattrlist<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$k</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">return</span> <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$k</span><span id="braces">}</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Add any nested elements</span><br />
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span>;
  <span id="perlKey">while</span><span id="braces">(</span><span id="var">@_</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$key</span> = <span id="perlFunc">shift</span>;
    <span id="var">$val</span> = <span id="perlFunc">shift</span>;

    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$val</span> = <span id="var">$self</span>-&gt;<span id="method">collapse</span><span id="braces">(</span>@$val<span id="braces">)</span>;
      <span id="perlKey">next</span> <span id="perlKey">if</span><span id="braces">(</span>!<span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>  and  <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">elsif</span><span id="braces">(</span><span id="var">$key</span> <span id="perlKey">eq</span> <span id="sqStr">'0'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">next</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$val</span> =~ <span id="regExp">m{^\s*$}s</span><span id="braces">)</span>;  <span id="comment"># Skip all whitespace content</span><br />
      <span id="var">$val</span> = <span id="var">$self</span>-&gt;<span id="method">normalise_space</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> == 2<span id="braces">)</span>;

      <span id="comment"># do variable substitutions</span><br />
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlKey">my</span> <span id="var">$var</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span> 
        <span id="var">$val</span> =~ <span id="regExp">s{\$\{(\w+)\}}{ $self-&gt;get_var($1) }ge</span>;
      <span id="braces">}</span>

      
      <span id="comment"># look for variable definitions</span><br />
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlKey">my</span> <span id="var">$var</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>varattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span> 
        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span> <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$var</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="var">$self</span>-&gt;<span id="method">set_var</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$var</span><span id="braces">}</span>, <span id="var">$val</span><span id="braces">)</span>;
        <span id="braces">}</span>
      <span id="braces">}</span>


      <span id="comment"># Collapse text content in element with no attributes to a string</span><br />
      <span id="perlKey">if</span><span id="braces">(</span>!%$attr  and  !<span id="var">@_</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">return</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>forcecontent<span id="braces">}</span> ? 
          <span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span> =&gt; <span id="var">$val</span> <span id="braces">}</span> : <span id="var">$val</span>
        <span id="braces">)</span>;
      <span id="braces">}</span>
      <span id="var">$key</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span>;
    <span id="braces">}</span>


    <span id="comment"># Combine duplicate attributes into arrayref if required</span><br />
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlFunc">push</span><span id="braces">(</span>@<span id="braces">{</span><span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">}</span>, <span id="var">$val</span><span id="braces">)</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="braces">[</span> <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>, <span id="var">$val</span> <span id="braces">]</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
    <span id="perlKey">elsif</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>  and  <span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$val</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="braces">[</span> <span id="var">$val</span> <span id="braces">]</span>;
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span> <span id="var">$key</span> <span id="perlKey">ne</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span> 
          and <span id="braces">(</span>
            <span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> == 1<span id="braces">)</span>
            or <span id="braces">(</span> 
              <span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span>
              and <span id="braces">(</span>
                <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>
                or <span id="braces">(</span><span id="perlFunc">grep</span> <span id="var">$key</span> =~ <span id="var">$_</span>, @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span>-&gt;<span id="braces">{</span>_regex<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span>
              <span id="braces">)</span>
            <span id="braces">)</span>
          <span id="braces">)</span>
        <span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="braces">[</span> <span id="var">$val</span> <span id="braces">]</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="var">$val</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>

  <span id="braces">}</span>


  <span id="comment"># Turn arrayrefs into hashrefs if key fields present</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">while</span><span id="braces">(</span><span id="braces">(</span><span id="var">$key</span>,<span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span> %$attr<span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span>  and  <span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$val</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="var">$self</span>-&gt;<span id="method">array_to_hash</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># disintermediate grouped tags</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span><span id="braces">(</span>%$attr<span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">next</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$val</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span> and <span id="braces">(</span><span id="perlFunc">keys</span> %$val == 1<span id="braces">)</span><span id="braces">)</span>;
      <span id="perlKey">next</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;

      <span id="perlKey">my</span><span id="braces">(</span><span id="var">$child_key</span>, <span id="var">$child_val</span><span id="braces">)</span> =  %$val;

      <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> <span id="perlKey">eq</span> <span id="var">$child_key</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>= <span id="var">$child_val</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Fold hashes containing a single anonymous array up into just the array</span><br />
  <span id="perlKey">my</span> <span id="var">$count</span> = <span id="perlFunc">scalar</span> <span id="perlFunc">keys</span> %$attr;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$count</span> == 1 
     and  <span id="perlFunc">exists</span> <span id="var">$attr</span>-&gt;<span id="braces">{</span>anon<span id="braces">}</span>  
     and  <span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span>anon<span id="braces">}</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span>
  <span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span>anon<span id="braces">}</span><span id="braces">)</span>;
  <span id="braces">}</span>


  <span id="comment"># Do the right thing if hash is empty, otherwise just return it</span><br />
  <span id="perlKey">if</span><span id="braces">(</span>!%$attr  and  <span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span>  and
       <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span> <span id="perlKey">eq</span> <span id="sqStr">''</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="sqStr">''</span><span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="perlFunc">undef</span><span id="braces">)</span>;
  <span id="braces">}</span>


  <span id="comment"># Roll up named elements with named nested 'value' attributes</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span><span id="braces">(</span>%$attr<span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">next</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span>;
      <span id="perlKey">next</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$val</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span> and <span id="braces">(</span><span id="perlFunc">keys</span> %$val == 1<span id="braces">)</span><span id="braces">)</span>;
      <span id="perlKey">my</span><span id="braces">(</span><span id="var">$k</span><span id="braces">)</span> = <span id="perlFunc">keys</span> %$val;
      <span id="perlKey">next</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$k</span> <span id="perlKey">eq</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span>;
      <span id="var">$attr</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="var">$val</span>-&gt;<span id="braces">{</span><span id="var">$k</span><span id="braces">}</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$attr</span><span id="braces">)</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE15" id="CODE15"></a>collapse_content</td><td >description</td><td ><a href="#CODE14">prev</a></td><td ><a href="#CODE16">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">collapse_content</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>       = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$hashref</span>    = <span id="perlFunc">shift</span>; 

  <span id="perlKey">my</span> <span id="var">$contentkey</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span>;

  <span id="comment"># first go through the values,checking that they are fit to collapse</span><br />  <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$val</span> <span id="braces">(</span><span id="perlFunc">values</span> %$hashref<span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span> <span id="var">$hashref</span> <span id="perlKey">unless</span> <span id="braces">(</span>     <span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$val</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span>
                             and <span id="braces">(</span><span id="perlFunc">keys</span> %$val == 1<span id="braces">)</span>
                             and <span id="braces">(</span><span id="perlFunc">exists</span> <span id="var">$val</span>-&gt;<span id="braces">{</span><span id="var">$contentkey</span><span id="braces">}</span><span id="braces">)</span>
                           <span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="comment"># now collapse them</span><br />  <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$key</span> <span id="braces">(</span><span id="perlFunc">keys</span> %$hashref<span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>=  <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$contentkey</span><span id="braces">}</span>;
  <span id="braces">}</span>

  <span id="perlKey">return</span> <span id="var">$hashref</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE16" id="CODE16"></a>copy_hash</td><td >description</td><td ><a href="#CODE15">prev</a></td><td ><a href="#CODE17">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">copy_hash</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$orig</span>, <span id="var">@extra</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">return</span> <span id="braces">{</span> <span id="var">@extra</span>, %$orig <span id="braces">}</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE17" id="CODE17"></a>end_document</td><td >description</td><td ><a href="#CODE16">prev</a></td><td ><a href="#CODE18">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">end_document</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;

  <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span><span id="braces">)</span>;
  <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>lists<span id="braces">}</span><span id="braces">)</span>;

  <span id="perlKey">my</span> <span id="var">$tree</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>tree<span id="braces">}</span>;
  <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>tree<span id="braces">}</span><span id="braces">)</span>;


  <span id="comment"># Return tree as-is to XMLin()</span><br />
  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>nocollapse<span id="braces">}</span><span id="braces">)</span>;


  <span id="comment"># Or collapse it before returning it to SAX parser class</span><br />  
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keeproot<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$tree</span> = <span id="var">$self</span>-&gt;<span id="method">collapse</span><span id="braces">(</span><span id="braces">{</span><span id="braces">}</span>, @$tree<span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$tree</span> = <span id="var">$self</span>-&gt;<span id="method">collapse</span><span id="braces">(</span>@<span id="braces">{</span><span id="var">$tree</span>-&gt;<span id="braces">[</span>1<span id="braces">]</span><span id="braces">}</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>datahandler<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>datahandler<span id="braces">}</span>-&gt;<span id="braces">(</span><span id="var">$self</span>, <span id="var">$tree</span><span id="braces">)</span><span id="braces">)</span>;
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$tree</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE18" id="CODE18"></a>end_element</td><td >description</td><td ><a href="#CODE17">prev</a></td><td ><a href="#CODE19">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">end_element</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>    = <span id="perlFunc">shift</span>;

  <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span> = <span id="perlFunc">pop</span> @<span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>lists<span id="braces">}</span> <span id="braces">}</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE19" id="CODE19"></a>escape_value</td><td >description</td><td ><a href="#CODE18">prev</a></td><td ><a href="#CODE20">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">escape_value</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$data</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">return</span> <span id="sqStr">''</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$data</span><span id="braces">)</span><span id="braces">)</span>;

  <span id="var">$data</span> =~ <span id="regExp">s/&amp;/&amp;amp;/sg</span>;
  <span id="var">$data</span> =~ <span id="regExp">s/&lt;/&amp;lt;/sg</span>;
  <span id="var">$data</span> =~ <span id="regExp">s/&gt;/&amp;gt;/sg</span>;
  <span id="var">$data</span> =~ <span id="regExp">s/&quot;/&amp;quot;/sg</span>;

  <span id="perlKey">my</span> <span id="var">$level</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>numericescape<span id="braces">}</span> or <span id="perlKey">return</span> <span id="var">$data</span>;

  <span id="perlKey">return</span> <span id="var">$self</span>-&gt;<span id="method">numeric_escape</span><span id="braces">(</span><span id="var">$data</span>, <span id="var">$level</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE20" id="CODE20"></a>find_xml_file</td><td >description</td><td ><a href="#CODE19">prev</a></td><td ><a href="#CODE21">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">find_xml_file</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$file</span> = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">@search_path</span> = <span id="var">@_</span>;


  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$filename</span>, <span id="var">$filedir</span><span id="braces">)</span> =
    <span id="module">File::Basename</span>::<span id="method">fileparse</span><span id="braces">(</span><span id="var">$file</span><span id="braces">)</span>;

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$filename</span> <span id="perlKey">ne</span> <span id="var">$file</span><span id="braces">)</span> <span id="braces">{</span>        <span id="comment"># Ignore searchpath if dir component</span><br />    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$file</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span>-e <span id="var">$file</span><span id="braces">)</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">my</span><span id="braces">(</span><span id="var">$path</span><span id="braces">)</span>;
    <span id="perlKey">foreach</span> <span id="var">$path</span> <span id="braces">(</span><span id="var">@search_path</span><span id="braces">)</span>  <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">$fullpath</span> = <span id="module">File::Spec</span>-&gt;<span id="method">catfile</span><span id="braces">(</span><span id="var">$path</span>, <span id="var">$file</span><span id="braces">)</span>;
      <span id="perlKey">return</span><span id="braces">(</span><span id="var">$fullpath</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span>-e <span id="var">$fullpath</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="comment"># If user did not supply a search path, default to current directory</span><br />
  <span id="perlKey">if</span><span id="braces">(</span>!<span id="var">@search_path</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$file</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span>-e <span id="var">$file</span><span id="braces">)</span>;
    croak <span id="dqStr">"File does not exist: <span id="var">$file</span>"</span>;
  <span id="braces">}</span>

  croak <span id="dqStr">"Could not find <span id="var">$file</span> in "</span>, <span id="perlFunc">join</span><span id="braces">(</span><span id="sqStr">':'</span>, <span id="var">@search_path</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE21" id="CODE21"></a>get_var</td><td >description</td><td ><a href="#CODE20">prev</a></td><td ><a href="#CODE22">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">get_var</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$name</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">my</span> <span id="var">$value</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span>;
  <span id="perlKey">return</span> <span id="var">$value</span> <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span><span id="braces">)</span>;

  <span id="perlKey">return</span> <span id="sqStr">'${'</span> . <span id="var">$name</span> . <span id="sqStr">'}'</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE22" id="CODE22"></a>handle_options</td><td >description</td><td ><a href="#CODE21">prev</a></td><td ><a href="#CODE23">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">handle_options</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$dirn</span> = <span id="perlFunc">shift</span>;


  <span id="comment"># Determine valid options based on context</span><br />
  <span id="perlKey">my</span> <span id="var">%known_opt</span>; 
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$dirn</span> <span id="perlKey">eq</span> <span id="sqStr">'in'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">@known_opt</span><span id="braces">{</span><span id="var">@KnownOptIn</span><span id="braces">}</span> = <span id="var">@KnownOptIn</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">@known_opt</span><span id="braces">{</span><span id="var">@KnownOptOut</span><span id="braces">}</span> = <span id="var">@KnownOptOut</span>;
  <span id="braces">}</span>


  <span id="comment"># Store supplied options in hashref and weed out invalid ones</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">@_</span> % 2<span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"Options must be name=&gt;value pairs (odd number supplied)"</span>;
  <span id="braces">}</span>
  <span id="perlKey">my</span> <span id="var">%raw_opt</span>  = <span id="var">@_</span>;
  <span id="perlKey">my</span> <span id="var">$opt</span>      = <span id="braces">{</span><span id="braces">}</span>;
  <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span> = <span id="var">$opt</span>;

  <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span> <span id="var">%raw_opt</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">my</span> <span id="var">$lkey</span> = <span id="perlFunc">lc</span><span id="braces">(</span><span id="var">$key</span><span id="braces">)</span>;
    <span id="var">$lkey</span> =~ <span id="regExp">s/_//g</span>;
    croak <span id="dqStr">"Unrecognised option: <span id="var">$key</span>"</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$known_opt</span><span id="braces">{</span><span id="var">$lkey</span><span id="braces">}</span><span id="braces">)</span>;
    <span id="var">$opt</span>-&gt;<span id="braces">{</span><span id="var">$lkey</span><span id="braces">}</span> = <span id="var">$val</span>;
  <span id="braces">}</span>


  <span id="comment"># Merge in options passed to constructor</span><br />
  <span id="perlKey">foreach</span> <span id="braces">(</span><span id="perlFunc">keys</span><span id="braces">(</span><span id="var">%known_opt</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>def_opt<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$opt</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>def_opt<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Set sensible defaults if not supplied</span><br />  
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span> = <span id="sqStr">''</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>rootname<span id="braces">}</span> = <span id="var">$DefRootName</span>;
  <span id="braces">}</span>
  
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>xmldecl<span id="braces">}</span>  and  <span id="var">$opt</span>-&gt;<span id="braces">{</span>xmldecl<span id="braces">}</span> <span id="perlKey">eq</span> <span id="sqStr">'1'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>xmldecl<span id="braces">}</span> = <span id="var">$DefXmlDecl</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span> =~ <span id="regExp">m{^-(.*)$}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span> = <span id="var">$1</span>;
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>collapseagain<span id="braces">}</span> = 1;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span> = <span id="var">$DefContentKey</span>;
  <span id="braces">}</span>

  <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> = <span id="var">$opt</span>-&gt;<span id="braces">{</span>normalizespace<span id="braces">}</span>;
  <span id="braces">}</span>
  <span id="var">$opt</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span> = 0 <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>normalisespace<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;

  <span id="comment"># Cleanups for values assumed to be arrays later</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span> = <span id="braces">[</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span> <span id="braces">]</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span>  <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>searchpath<span id="braces">}</span> = <span id="braces">[</span> <span id="braces">]</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span>  and !<span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span> = <span id="braces">[</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span> <span id="braces">]</span>;
  <span id="braces">}</span>
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$_</span> = <span id="perlFunc">lc</span><span id="braces">(</span><span id="var">$_</span><span id="braces">)</span> <span id="perlKey">foreach</span> <span id="braces">(</span>@<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span>;
    <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$scheme</span> <span id="braces">(</span>@<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>cache<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">$method</span> = <span id="sqStr">'cache_read_'</span> . <span id="var">$scheme</span>;
      croak <span id="dqStr">"Unsupported caching scheme: <span id="var">$scheme</span>"</span>
        <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="method">can</span><span id="braces">(</span><span id="var">$method</span><span id="braces">)</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>parseropts<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span>$^W<span id="braces">)</span> <span id="braces">{</span>
      carp <span id="dqStr">"Warning: "</span> .
           <span id="dqStr">"'ParserOpts' is deprecated, contact the author if you need it"</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>parseropts<span id="braces">}</span> = <span id="braces">[</span> <span id="braces">]</span>;
  <span id="braces">}</span>

  
  <span id="comment"># Special cleanup for {forcearray} which could be regex, arrayref or boolean</span><br />  <span id="comment"># or left to default to 0</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'Regexp'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> = <span id="braces">[</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> <span id="braces">]</span>;
    <span id="braces">}</span>

    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'ARRAY'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">@force_list</span> = @<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">}</span>;
      <span id="perlKey">if</span><span id="braces">(</span><span id="var">@force_list</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> = <span id="braces">{</span><span id="braces">}</span>;
        <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$tag</span> <span id="braces">(</span><span id="var">@force_list</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$tag</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'Regexp'</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="perlFunc">push</span> @<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span>-&gt;<span id="braces">{</span>_regex<span id="braces">}</span><span id="braces">}</span>, <span id="var">$tag</span>;
          <span id="braces">}</span>
          <span id="perlKey">else</span> <span id="braces">{</span>
            <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$tag</span><span id="braces">}</span> = 1;
          <span id="braces">}</span>
        <span id="braces">}</span>
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> = 0;
      <span id="braces">}</span>
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> = <span id="braces">(</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> ? 1 : 0 <span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$StrictMode</span>  and  <span id="var">$dirn</span> <span id="perlKey">eq</span> <span id="sqStr">'in'</span><span id="braces">)</span> <span id="braces">{</span>
      croak <span id="dqStr">"No value specified for 'ForceArray' option in call to XML<span id="var">$dirn</span>()"</span>;
    <span id="braces">}</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> = 0;
  <span id="braces">}</span>


  <span id="comment"># Special cleanup for {keyattr} which could be arrayref or hashref or left</span><br />  <span id="comment"># to default to arrayref</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>  <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span> <span id="braces">{</span>

        <span id="comment"># Make a copy so we can mess with it</span><br />
        <span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span> = <span id="braces">{</span> %<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">}</span> <span id="braces">}</span>;

        
        <span id="comment"># Convert keyattr =&gt; { elem =&gt; '+attr' }</span><br />        <span id="comment"># to keyattr =&gt; { elem =&gt; [ 'attr', '+' ] } </span><br />
        <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$el</span> <span id="braces">(</span><span id="perlFunc">keys</span><span id="braces">(</span>%<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$el</span><span id="braces">}</span> =~ <span id="regExp">/^(\+|-)?(.*)$/</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$el</span><span id="braces">}</span> = <span id="braces">[</span> <span id="var">$2</span>, <span id="braces">(</span><span id="var">$1</span> ? <span id="var">$1</span> : <span id="sqStr">''</span><span id="braces">)</span> <span id="braces">]</span>;
            <span id="perlKey">if</span><span id="braces">(</span><span id="var">$StrictMode</span>  and  <span id="var">$dirn</span> <span id="perlKey">eq</span> <span id="sqStr">'in'</span><span id="braces">)</span> <span id="braces">{</span>
              <span id="perlKey">next</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span> == 1<span id="braces">)</span>;
              <span id="perlKey">next</span> <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span>
                      and <span id="var">$opt</span>-&gt;<span id="braces">{</span>forcearray<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$el</span><span id="braces">}</span><span id="braces">)</span>;
              croak <span id="dqStr">"&lt;<span id="var">$el</span>&gt; set in KeyAttr but not in ForceArray"</span>;
            <span id="braces">}</span>
          <span id="braces">}</span>
          <span id="perlKey">else</span> <span id="braces">{</span>
            <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$el</span><span id="braces">}</span><span id="braces">)</span>; <span id="comment"># Never reached (famous last words?)</span><br />          <span id="braces">}</span>
        <span id="braces">}</span>
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="perlKey">if</span><span id="braces">(</span>@<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">}</span> == 0<span id="braces">)</span> <span id="braces">{</span>
          <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span>;
        <span id="braces">}</span>
      <span id="braces">}</span>
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span> = <span id="braces">[</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span> <span id="braces">]</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">else</span>  <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$StrictMode</span><span id="braces">)</span> <span id="braces">{</span>
      croak <span id="dqStr">"No value specified for 'KeyAttr' option in call to XML<span id="var">$dirn</span>()"</span>;
    <span id="braces">}</span>
    <span id="var">$opt</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span> = <span id="braces">[</span> <span id="var">@DefKeyAttr</span> <span id="braces">]</span>;
  <span id="braces">}</span>


  <span id="comment"># Special cleanup for {valueattr} which could be arrayref or hashref</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'ARRAY'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>valueattrlist<span id="braces">}</span> = <span id="braces">{</span><span id="braces">}</span>;
      <span id="var">$opt</span>-&gt;<span id="braces">{</span>valueattrlist<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$_</span><span id="braces">}</span> = 1 <span id="perlKey">foreach</span><span id="braces">(</span>@<span id="braces">{</span> <span id="perlFunc">delete</span> <span id="var">$opt</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span> <span id="braces">}</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="comment"># make sure there's nothing weird in {grouptags}</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"Illegal value for 'GroupTags' option - expected a hashref"</span>
      <span id="perlKey">unless</span> <span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span>;

    <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span> %<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">next</span> <span id="perlKey">if</span> <span id="var">$key</span> <span id="perlKey">ne</span> <span id="var">$val</span>;
      croak <span id="dqStr">"Bad value in GroupTags: '$key' =&gt; '$val'"</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Check the {variables} option is valid and initialise variables hash</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>variables<span id="braces">}</span> and !<span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>variables<span id="braces">}</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"Illegal value for 'Variables' option - expected a hashref"</span>;
  <span id="braces">}</span>

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>variables<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span> 
    <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span> = <span id="braces">{</span> %<span id="braces">{</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>variables<span id="braces">}</span><span id="braces">}</span> <span id="braces">}</span>;
  <span id="braces">}</span>
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="var">$opt</span>-&gt;<span id="braces">{</span>varattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span> 
    <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span> = <span id="braces">{</span><span id="braces">}</span>;
  <span id="braces">}</span></pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE23" id="CODE23"></a>hash_to_array</td><td >description</td><td ><a href="#CODE22">prev</a></td><td ><a href="#CODE24">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">hash_to_array</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>    = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$parent</span>  = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$hashref</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">my</span> <span id="var">$arrayref</span> = <span id="braces">[</span><span id="braces">]</span>;

  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$value</span><span id="braces">)</span>;

  <span id="perlKey">my</span> <span id="var">@keys</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nosort<span id="braces">}</span> ? <span id="perlFunc">keys</span> %$hashref : <span id="perlFunc">sort</span> <span id="perlFunc">keys</span> %$hashref;
  <span id="perlKey">foreach</span> <span id="var">$key</span> <span id="braces">(</span><span id="var">@keys</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$value</span> = <span id="var">$hashref</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>;
    <span id="perlKey">return</span><span id="braces">(</span><span id="var">$hashref</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$value</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span>;

    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span><span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="var">$hashref</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$parent</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;
      <span id="perlFunc">push</span> @$arrayref, <span id="var">$self</span>-&gt;<span id="method">copy_hash</span><span id="braces">(</span>
        <span id="var">$value</span>, <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$parent</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span> =&gt; <span id="var">$key</span>
      <span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="perlFunc">push</span><span id="braces">(</span>@$arrayref, <span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span> =&gt; <span id="var">$key</span>, %$value <span id="braces">}</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">$arrayref</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE24" id="CODE24"></a>import</td><td >description</td><td ><a href="#CODE23">prev</a></td><td ><a href="#CODE25">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">import</span>
{<pre>
  <span id="comment"># Handle the :strict tag</span><br />  
  <span id="var">$StrictMode</span> = 1 <span id="perlKey">if</span> <span id="perlFunc">grep</span><span id="braces">(</span><span id="regExp">/^:strict$/</span>, <span id="var">@_</span><span id="braces">)</span>;

  <span id="comment"># Pass everything else to Exporter.pm</span><br />
  <span id="method">__PACKAGE__</span><span id="method">->export_to_level</span><span id="braces">(</span>1, <span id="perlFunc">grep</span><span id="braces">(</span>!<span id="regExp">/^:strict$/</span>, <span id="var">@_</span><span id="braces">)</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE25" id="CODE25"></a>new</td><td >description</td><td ><a href="#CODE24">prev</a></td><td ><a href="#CODE26">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">new</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$class</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">if</span><span id="braces">(</span><span id="var">@_</span> % 2<span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"Default options must be name=&gt;value pairs (odd number supplied)"</span>;
  <span id="braces">}</span>

  <span id="perlKey">my</span> <span id="var">%known_opt</span>;
  <span id="var">@known_opt</span><span id="braces">{</span><span id="var">@KnownOptIn</span>, <span id="var">@KnownOptOut</span><span id="braces">}</span> = <span id="braces">(</span><span id="perlFunc">undef</span><span id="braces">)</span> x 100;

  <span id="perlKey">my</span> <span id="var">%raw_opt</span> = <span id="var">@_</span>;
  <span id="perlKey">my</span> <span id="var">%def_opt</span>;
  <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span> <span id="var">%raw_opt</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">my</span> <span id="var">$lkey</span> = <span id="perlFunc">lc</span><span id="braces">(</span><span id="var">$key</span><span id="braces">)</span>;
    <span id="var">$lkey</span> =~ <span id="regExp">s/_//g</span>;
    croak <span id="dqStr">"Unrecognised option: <span id="var">$key</span>"</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$known_opt</span><span id="braces">{</span><span id="var">$lkey</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;
    <span id="var">$def_opt</span><span id="braces">{</span><span id="var">$lkey</span><span id="braces">}</span> = <span id="var">$val</span>;
  <span id="braces">}</span>
  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="braces">{</span> def_opt =&gt;\% def_opt <span id="braces">}</span>;

  <span id="perlKey">return</span><span id="braces">(</span><span id="perlFunc">bless</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$class</span><span id="braces">)</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE26" id="CODE26"></a>new_hashref</td><td >description</td><td ><a href="#CODE25">prev</a></td><td ><a href="#CODE27">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">new_hashref</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">return</span> <span id="braces">{</span> <span id="var">@_</span> <span id="braces">}</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE27" id="CODE27"></a>normalise_space</td><td >description</td><td ><a href="#CODE26">prev</a></td><td ><a href="#CODE28">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">normalise_space</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$text</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="var">$text</span> =~ <span id="regExp">s/^\s+//s</span>;
  <span id="var">$text</span> =~ <span id="regExp">s/\s+$//s</span>;
  <span id="var">$text</span> =~ <span id="regExp">s/\s\s+/ /sg</span>;

  <span id="perlKey">return</span> <span id="var">$text</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE28" id="CODE28"></a>numeric_escape</td><td >description</td><td ><a href="#CODE27">prev</a></td><td ><a href="#CODE29">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">numeric_escape</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$data</span>, <span id="var">$level</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">use</span> utf8; <span id="comment"># required for 5.6</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>numericescape<span id="braces">}</span> <span id="perlKey">eq</span> <span id="sqStr">'2'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$data</span> =~ <span id="regExp">s/([^\x00-\x7F])/'&amp;#' . ord(</span><span id="var">$1</span><span id="regExp">) . ';'/gse</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="var">$data</span> =~ <span id="regExp">s/([^\x00-\xFF])/'&amp;#' . ord(</span><span id="var">$1</span><span id="regExp">) . ';'/gse</span>;
  <span id="braces">}</span>

  <span id="perlKey">return</span> <span id="var">$data</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE29" id="CODE29"></a>set_var</td><td >description</td><td ><a href="#CODE28">prev</a></td><td ><a href="#CODE30">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">set_var</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$name</span>, <span id="var">$value</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="var">$self</span>-&gt;<span id="braces">{</span>_var_values<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span> = <span id="var">$value</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE30" id="CODE30"></a>sorted_keys</td><td >description</td><td ><a href="#CODE29">prev</a></td><td ><a href="#CODE31">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">sorted_keys</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$name</span>, <span id="var">$ref</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">return</span> <span id="perlFunc">keys</span> %$<span id="perlFunc">ref</span> <span id="perlKey">if</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nosort<span id="braces">}</span>;

  <span id="perlKey">my</span> <span id="var">%hash</span> = %$<span id="perlFunc">ref</span>;
  <span id="perlKey">my</span> <span id="var">$keyattr</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>;

  <span id="perlKey">my</span> <span id="var">@key</span>;

  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span> <span id="var">$keyattr</span> <span id="perlKey">eq</span> <span id="sqStr">'HASH'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span> <span id="var">$keyattr</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span> and <span id="perlFunc">exists</span> <span id="var">$hash</span><span id="braces">{</span><span id="var">$keyattr</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlFunc">push</span> <span id="var">@key</span>, <span id="var">$keyattr</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span>;
      <span id="perlFunc">delete</span> <span id="var">$hash</span><span id="braces">{</span><span id="var">$keyattr</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span>-&gt;<span id="braces">[</span>0<span id="braces">]</span><span id="braces">}</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="perlFunc">ref</span> <span id="var">$keyattr</span> <span id="perlKey">eq</span> <span id="sqStr">'ARRAY'</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">foreach</span> <span id="braces">(</span>@<span id="braces">{</span><span id="var">$keyattr</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span> <span id="var">$hash</span><span id="braces">{</span><span id="var">$_</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@key</span>, <span id="var">$_</span>;
        <span id="perlFunc">delete</span> <span id="var">$hash</span><span id="braces">{</span><span id="var">$_</span><span id="braces">}</span>;
        <span id="perlKey">last</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="perlKey">return</span><span id="braces">(</span><span id="var">@key</span>, <span id="perlFunc">sort</span> <span id="perlFunc">keys</span> <span id="var">%hash</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE31" id="CODE31"></a>start_document</td><td >description</td><td ><a href="#CODE30">prev</a></td><td ><a href="#CODE32">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">start_document</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;

  <span id="var">$self</span>-&gt;<span id="method">handle_options</span><span id="braces">(</span><span id="sqStr">'in'</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span><span id="braces">)</span>;

  <span id="var">$self</span>-&gt;<span id="braces">{</span>lists<span id="braces">}</span> = <span id="braces">[</span><span id="braces">]</span>;
  <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>tree<span id="braces">}</span> = <span id="braces">[</span><span id="braces">]</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE32" id="CODE32"></a>start_element</td><td >description</td><td ><a href="#CODE31">prev</a></td><td ><a href="#CODE33">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">start_element</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span>    = <span id="perlFunc">shift</span>;
  <span id="perlKey">my</span> <span id="var">$element</span> = <span id="perlFunc">shift</span>;

  <span id="perlKey">my</span> <span id="var">$name</span> = <span id="var">$element</span>-&gt;<span id="braces">{</span>Name<span id="braces">}</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nsexpand<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$name</span> = <span id="var">$element</span>-&gt;<span id="braces">{</span>LocalName<span id="braces">}</span> || <span id="sqStr">''</span>;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$element</span>-&gt;<span id="braces">{</span>NamespaceURI<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$name</span> = <span id="sqStr">'{'</span> . <span id="var">$element</span>-&gt;<span id="braces">{</span>NamespaceURI<span id="braces">}</span> . <span id="sqStr">'}'</span> . <span id="var">$name</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">my</span> <span id="var">$attributes</span> = <span id="braces">{</span><span id="braces">}</span>;
  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$element</span>-&gt;<span id="braces">{</span>Attributes<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>  <span id="comment"># Might be undef</span><br />    <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$attr</span> <span id="braces">(</span><span id="perlFunc">values</span> %<span id="braces">{</span><span id="var">$element</span>-&gt;<span id="braces">{</span>Attributes<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>nsexpand<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">my</span> <span id="var">$name</span> = <span id="var">$attr</span>-&gt;<span id="braces">{</span>LocalName<span id="braces">}</span> || <span id="sqStr">''</span>;
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">$attr</span>-&gt;<span id="braces">{</span>NamespaceURI<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="var">$name</span> = <span id="sqStr">'{'</span> . <span id="var">$attr</span>-&gt;<span id="braces">{</span>NamespaceURI<span id="braces">}</span> . <span id="sqStr">'}'</span> . <span id="var">$name</span>
        <span id="braces">}</span>
        <span id="var">$name</span> = <span id="sqStr">'xmlns'</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$name</span> <span id="perlKey">eq</span> <span id="var">$bad_def_ns_jcn</span><span id="braces">)</span>;
        <span id="var">$attributes</span>-&gt;<span id="braces">{</span><span id="var">$name</span><span id="braces">}</span> = <span id="var">$attr</span>-&gt;<span id="braces">{</span>Value<span id="braces">}</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="var">$attributes</span>-&gt;<span id="braces">{</span><span id="var">$attr</span>-&gt;<span id="braces">{</span>Name<span id="braces">}</span><span id="braces">}</span> = <span id="var">$attr</span>-&gt;<span id="braces">{</span>Value<span id="braces">}</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>
  <span id="perlKey">my</span> <span id="var">$newlist</span> = <span id="braces">[</span> <span id="var">$attributes</span> <span id="braces">]</span>;
  <span id="perlFunc">push</span> @<span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>lists<span id="braces">}</span> <span id="braces">}</span>, <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span>;
  <span id="perlFunc">push</span> @<span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span> <span id="braces">}</span>, <span id="var">$name</span> =&gt; <span id="var">$newlist</span>;
  <span id="var">$self</span>-&gt;<span id="braces">{</span>curlist<span id="braces">}</span> = <span id="var">$newlist</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE33" id="CODE33"></a>storable_filename</td><td >description</td><td ><a href="#CODE32">prev</a></td><td ><a href="#CODE34">next</a></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">storable_filename</span>
{<pre>  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$self</span>, <span id="var">$cachefile</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="var">$cachefile</span> =~ <span id="regExp">s{(\.xml)?$}{.stor}</span>;
  <span id="perlKey">return</span> <span id="var">$cachefile</span>;</pre>}</td></div>
<div id="sep"></div>
<table id="methCodeTitle" width="100%"><tr><td width="200"><a name="CODE34" id="CODE34"></a>value_to_xml</td><td >description</td><td ><a href="#CODE33">prev</a></td><td >next</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="methCodeArea"><td ><span id="sub">sub</span> <span id="subName">value_to_xml</span>
{<pre>  <span id="perlKey">my</span> <span id="var">$self</span> = <span id="perlFunc">shift</span>;;


  <span id="comment"># Grab the other arguments</span><br />
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$ref</span>, <span id="var">$name</span>, <span id="var">$indent</span><span id="braces">)</span> = <span id="var">@_</span>;

  <span id="perlKey">my</span> <span id="var">$named</span> = <span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$name</span><span id="braces">)</span> and <span id="var">$name</span> <span id="perlKey">ne</span> <span id="sqStr">''</span> ? 1 : 0<span id="braces">)</span>;

  <span id="perlKey">my</span> <span id="var">$nl</span> = <span id="dqStr">"\n"</span>;

  <span id="perlKey">my</span> <span id="var">$is_root</span> = <span id="var">$indent</span> <span id="perlKey">eq</span> <span id="sqStr">''</span> ? 1 : 0;   <span id="comment"># Warning, dirty hack!</span><br />  <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noindent<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$indent</span> = <span id="sqStr">''</span>;
    <span id="var">$nl</span>     = <span id="sqStr">''</span>;
  <span id="braces">}</span>


  <span id="comment"># Convert to XML</span><br />  
  <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    croak <span id="dqStr">"circular data structures not supported"</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">grep</span><span id="braces">(</span><span id="var">$_</span> == <span id="var">$ref</span>, @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>_ancestors<span id="braces">}</span><span id="braces">}</span><span id="braces">)</span><span id="braces">)</span>;
    <span id="perlFunc">push</span> @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>_ancestors<span id="braces">}</span><span id="braces">}</span>, <span id="var">$ref</span>;
  <span id="braces">}</span>
  <span id="perlKey">else</span> <span id="braces">{</span>
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$named</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="perlFunc">join</span><span id="braces">(</span><span id="sqStr">''</span>,
              <span id="var">$indent</span>, <span id="sqStr">'&lt;'</span>, <span id="var">$name</span>, <span id="sqStr">'&gt;'</span>,
              <span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noescape<span id="braces">}</span> ? <span id="var">$ref</span> : <span id="var">$self</span>-&gt;<span id="method">escape_value</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span><span id="braces">)</span>,
              <span id="sqStr">'&lt;/'</span>, <span id="var">$name</span>, <span id="dqStr">"&gt;"</span>, <span id="var">$nl</span>
            <span id="braces">)</span><span id="braces">)</span>;
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="perlKey">return</span><span id="braces">(</span><span id="dqStr">"<span id="var">$ref</span><span id="var">$nl</span>"</span><span id="braces">)</span>;
    <span id="braces">}</span>
  <span id="braces">}</span>


  <span id="comment"># Unfold hash to array if possible</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$ref</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span>      <span id="comment"># It is a hash</span><br />     and <span id="perlFunc">keys</span> %$<span id="perlFunc">ref</span>                    <span id="comment"># and it's not empty</span><br />     and <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>keyattr<span id="braces">}</span>       <span id="comment"># and folding is enabled</span><br />     and !<span id="var">$is_root</span>                     <span id="comment"># and its not the root element</span><br />  <span id="braces">)</span> <span id="braces">{</span>
    <span id="var">$ref</span> = <span id="var">$self</span>-&gt;<span id="method">hash_to_array</span><span id="braces">(</span><span id="var">$name</span>, <span id="var">$ref</span><span id="braces">)</span>;
  <span id="braces">}</span>


  <span id="perlKey">my</span> <span id="var">@result</span> = <span id="braces">(</span><span id="braces">)</span>;
  <span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$value</span><span id="braces">)</span>;


  <span id="comment"># Handle hashrefs</span><br />
  <span id="perlKey">if</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$ref</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>

    <span id="comment"># Reintermediate grouped values if applicable</span><br />
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$ref</span> = <span id="var">$self</span>-&gt;<span id="method">copy_hash</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span>;
      <span id="perlKey">while</span><span id="braces">(</span><span id="perlKey">my</span><span id="braces">(</span><span id="var">$key</span>, <span id="var">$val</span><span id="braces">)</span> = <span id="perlFunc">each</span> %$<span id="perlFunc">ref</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> = <span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>grouptags<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> =&gt; <span id="var">$val</span> <span id="braces">}</span>;
        <span id="braces">}</span>
      <span id="braces">}</span>
    <span id="braces">}</span>


    <span id="comment"># Scan for namespace declaration attributes</span><br />
    <span id="perlKey">my</span> <span id="var">$nsdecls</span> = <span id="sqStr">''</span>;
    <span id="perlKey">my</span> <span id="var">$default_ns_uri</span>;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="var">$ref</span> = <span id="var">$self</span>-&gt;<span id="method">copy_hash</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span>;
      <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">push_context</span><span id="braces">(</span><span id="braces">)</span>;

      <span id="comment"># Look for default namespace declaration first</span><br />
      <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$ref</span>-&gt;<span id="braces">{</span>xmlns<span id="braces">}</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">declare_prefix</span><span id="braces">(</span><span id="sqStr">''</span>, <span id="var">$ref</span>-&gt;<span id="braces">{</span>xmlns<span id="braces">}</span><span id="braces">)</span>;
        <span id="var">$nsdecls</span> .= <span id="perlFunc">qq</span><span id="dqStr">( xmlns=&quot;<span id="var">$ref</span>-&gt;{xmlns}&quot;)</span>; 
        <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$ref</span>-&gt;<span id="braces">{</span>xmlns<span id="braces">}</span><span id="braces">)</span>;
      <span id="braces">}</span>
      <span id="var">$default_ns_uri</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">get_uri</span><span id="braces">(</span><span id="sqStr">''</span><span id="braces">)</span>;


      <span id="comment"># Then check all the other keys</span><br />
      <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$qname</span> <span id="braces">(</span><span id="perlFunc">keys</span><span id="braces">(</span>%$<span id="perlFunc">ref</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">my</span><span id="braces">(</span><span id="var">$uri</span>, <span id="var">$lname</span><span id="braces">)</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">parse_jclark_notation</span><span id="braces">(</span><span id="var">$qname</span><span id="braces">)</span>;
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">$uri</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$uri</span> <span id="perlKey">eq</span> <span id="var">$xmlns_ns</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">declare_prefix</span><span id="braces">(</span><span id="var">$lname</span>, <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span><span id="braces">)</span>;
            <span id="var">$nsdecls</span> .= <span id="perlFunc">qq</span><span id="dqStr">( xmlns:<span id="var">$lname</span>=&quot;<span id="var">$ref</span>-&gt;{<span id="var">$qname</span>}&quot;)</span>; 
            <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span><span id="braces">)</span>;
          <span id="braces">}</span>
        <span id="braces">}</span>
      <span id="braces">}</span>

      <span id="comment"># Translate any remaining Clarkian names</span><br />
      <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$qname</span> <span id="braces">(</span><span id="perlFunc">keys</span><span id="braces">(</span>%$<span id="perlFunc">ref</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">my</span><span id="braces">(</span><span id="var">$uri</span>, <span id="var">$lname</span><span id="braces">)</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">parse_jclark_notation</span><span id="braces">(</span><span id="var">$qname</span><span id="braces">)</span>;
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">$uri</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$default_ns_uri</span>  and  <span id="var">$uri</span> <span id="perlKey">eq</span> <span id="var">$default_ns_uri</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$lname</span><span id="braces">}</span> = <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span>;
            <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span><span id="braces">)</span>;
          <span id="braces">}</span>
          <span id="perlKey">else</span> <span id="braces">{</span>
            <span id="perlKey">my</span> <span id="var">$prefix</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">get_prefix</span><span id="braces">(</span><span id="var">$uri</span><span id="braces">)</span>;
            <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$prefix</span><span id="braces">)</span> <span id="braces">{</span>
              <span id="comment"># $self-&gt;{nsup}-&gt;declare_prefix(undef, $uri);</span><br />              <span id="comment"># $prefix = $self-&gt;{nsup}-&gt;get_prefix($uri);</span><br />              <span id="var">$prefix</span> = <span id="var">$self</span>-&gt;<span id="braces">{</span>ns_prefix<span id="braces">}</span>++;
              <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">declare_prefix</span><span id="braces">(</span><span id="var">$prefix</span>, <span id="var">$uri</span><span id="braces">)</span>;
              <span id="var">$nsdecls</span> .= <span id="perlFunc">qq</span><span id="dqStr">( xmlns:<span id="var">$prefix</span>=&quot;$uri&quot;)</span>; 
            <span id="braces">}</span>
            <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="dqStr">"<span id="var">$prefix</span>:<span id="var">$lname</span>"</span><span id="braces">}</span> = <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span>;
            <span id="perlFunc">delete</span><span id="braces">(</span><span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$qname</span><span id="braces">}</span><span id="braces">)</span>;
          <span id="braces">}</span>
        <span id="braces">}</span>
      <span id="braces">}</span>
    <span id="braces">}</span>


    <span id="perlKey">my</span> <span id="var">@nested</span> = <span id="braces">(</span><span id="braces">)</span>;
    <span id="perlKey">my</span> <span id="var">$text_content</span> = <span id="perlFunc">undef</span>;
    <span id="perlKey">if</span><span id="braces">(</span><span id="var">$named</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">$indent</span>, <span id="sqStr">'&lt;'</span>, <span id="var">$name</span>, <span id="var">$nsdecls</span>;
    <span id="braces">}</span>

    <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">keys</span> %$<span id="perlFunc">ref</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">my</span> <span id="var">$first_arg</span> = 1;
      <span id="perlKey">foreach</span> <span id="perlKey">my</span> <span id="var">$key</span> <span id="braces">(</span><span id="var">$self</span>-&gt;<span id="method">sorted_keys</span><span id="braces">(</span><span id="var">$name</span>, <span id="var">$ref</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlKey">my</span> <span id="var">$value</span> = <span id="var">$ref</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>;
        <span id="perlKey">next</span> <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">substr</span><span id="braces">(</span><span id="var">$key</span>, 0, 1<span id="braces">)</span> <span id="perlKey">eq</span> <span id="sqStr">'-'</span><span id="braces">)</span>;
        <span id="perlKey">if</span><span id="braces">(</span>!<span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlKey">next</span> <span id="perlKey">if</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span>;
          <span id="perlKey">unless</span><span id="braces">(</span><span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span>
             and !<span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span>
          <span id="braces">)</span> <span id="braces">{</span>
            carp <span id="sqStr">'Use of uninitialized value'</span> <span id="perlKey">if</span><span id="braces">(</span>$^W<span id="braces">)</span>;
          <span id="braces">}</span>
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$key</span> <span id="perlKey">eq</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="var">$text_content</span> = <span id="sqStr">''</span>;
          <span id="braces">}</span>
          <span id="perlKey">else</span> <span id="braces">{</span>
            <span id="var">$value</span> = <span id="perlFunc">exists</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span><span id="braces">)</span> ? <span id="braces">{</span><span id="braces">}</span> : <span id="sqStr">''</span>;
          <span id="braces">}</span>
        <span id="braces">}</span>

        <span id="perlKey">if</span><span id="braces">(</span>!<span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span>  
           and <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span>
           and <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span>
        <span id="braces">)</span> <span id="braces">{</span>
          <span id="var">$value</span> = <span id="braces">{</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>valueattr<span id="braces">}</span>-&gt;<span id="braces">{</span><span id="var">$key</span><span id="braces">}</span> =&gt; <span id="var">$value</span> <span id="braces">}</span>;
        <span id="braces">}</span>

        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span>  or  <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noattr<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlFunc">push</span> <span id="var">@nested</span>,
            <span id="var">$self</span>-&gt;<span id="method">value_to_xml</span><span id="braces">(</span><span id="var">$value</span>, <span id="var">$key</span>, <span id="dqStr">"<span id="var">$indent</span>  "</span><span id="braces">)</span>;
        <span id="braces">}</span>
        <span id="perlKey">else</span> <span id="braces">{</span>
          <span id="var">$value</span> = <span id="var">$self</span>-&gt;<span id="method">escape_value</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span> <span id="perlKey">unless</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noescape<span id="braces">}</span><span id="braces">)</span>;
          <span id="perlKey">if</span><span id="braces">(</span><span id="var">$key</span> <span id="perlKey">eq</span> <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>contentkey<span id="braces">}</span><span id="braces">)</span> <span id="braces">{</span>
            <span id="var">$text_content</span> = <span id="var">$value</span>;
          <span id="braces">}</span>
          <span id="perlKey">else</span> <span id="braces">{</span>
            <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="dqStr">"\n<span id="var">$indent</span> "</span> . <span id="sqStr">' '</span> x <span id="perlFunc">length</span><span id="braces">(</span><span id="var">$name</span><span id="braces">)</span>
              <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>attrindent<span id="braces">}</span>  and  !<span id="var">$first_arg</span><span id="braces">)</span>;
            <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="sqStr">' '</span>, <span id="var">$key</span>, <span id="sqStr">'=&quot;'</span>, <span id="var">$value</span> , <span id="sqStr">'&quot;'</span>;
            <span id="var">$first_arg</span> = 0;
          <span id="braces">}</span>
        <span id="braces">}</span>
      <span id="braces">}</span>
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="var">$text_content</span> = <span id="sqStr">''</span>;
    <span id="braces">}</span>

    <span id="perlKey">if</span><span id="braces">(</span><span id="var">@nested</span>  or  <span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$text_content</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">if</span><span id="braces">(</span><span id="var">$named</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="dqStr">"&gt;"</span>;
        <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$text_content</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">$text_content</span>;
          <span id="var">$nested</span><span id="braces">[</span>0<span id="braces">]</span> =~ <span id="regExp">s/^\s+//</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">@nested</span><span id="braces">)</span>;
        <span id="braces">}</span>
        <span id="perlKey">else</span> <span id="braces">{</span>
          <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">$nl</span>;
        <span id="braces">}</span>
        <span id="perlKey">if</span><span id="braces">(</span><span id="var">@nested</span><span id="braces">)</span> <span id="braces">{</span>
          <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">@nested</span>, <span id="var">$indent</span>;
        <span id="braces">}</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="sqStr">'&lt;/'</span>, <span id="var">$name</span>, <span id="dqStr">"&gt;"</span>, <span id="var">$nl</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">@nested</span>;             <span id="comment"># Special case if no root elements</span><br />      <span id="braces">}</span>
    <span id="braces">}</span>
    <span id="perlKey">else</span> <span id="braces">{</span>
      <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="dqStr">" /&gt;"</span>, <span id="var">$nl</span>;
    <span id="braces">}</span>
    <span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span>-&gt;<span id="method">pop_context</span><span id="braces">(</span><span id="braces">)</span> <span id="perlKey">if</span><span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>nsup<span id="braces">}</span><span id="braces">)</span>;
  <span id="braces">}</span>


  <span id="comment"># Handle arrayrefs</span><br />
  <span id="perlKey">elsif</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$ref</span>, <span id="sqStr">'ARRAY'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
    <span id="perlKey">foreach</span> <span id="var">$value</span> <span id="braces">(</span>@$<span id="perlFunc">ref</span><span id="braces">)</span> <span id="braces">{</span>
      <span id="perlKey">next</span> <span id="perlKey">if</span> !<span id="perlFunc">defined</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span> and <span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>suppressempty<span id="braces">}</span>;
      <span id="perlKey">if</span><span id="braces">(</span>!<span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>,
             <span id="var">$indent</span>, <span id="sqStr">'&lt;'</span>, <span id="var">$name</span>, <span id="sqStr">'&gt;'</span>,
             <span id="braces">(</span><span id="var">$self</span>-&gt;<span id="braces">{</span>opt<span id="braces">}</span>-&gt;<span id="braces">{</span>noescape<span id="braces">}</span> ? <span id="var">$value</span> : <span id="var">$self</span>-&gt;<span id="method">escape_value</span><span id="braces">(</span><span id="var">$value</span><span id="braces">)</span><span id="braces">)</span>,
             <span id="sqStr">'&lt;/'</span>, <span id="var">$name</span>, <span id="dqStr">"&gt;<span id="var">$nl</span>"</span>;
      <span id="braces">}</span>
      <span id="perlKey">elsif</span><span id="braces">(</span><span id="module">UNIVERSAL</span>::<span id="method">isa</span><span id="braces">(</span><span id="var">$value</span>, <span id="sqStr">'HASH'</span><span id="braces">)</span><span id="braces">)</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>, <span id="var">$self</span>-&gt;<span id="method">value_to_xml</span><span id="braces">(</span><span id="var">$value</span>, <span id="var">$name</span>, <span id="var">$indent</span><span id="braces">)</span>;
      <span id="braces">}</span>
      <span id="perlKey">else</span> <span id="braces">{</span>
        <span id="perlFunc">push</span> <span id="var">@result</span>,
               <span id="var">$indent</span>, <span id="sqStr">'&lt;'</span>, <span id="var">$name</span>, <span id="dqStr">"&gt;<span id="var">$nl</span>"</span>,
               <span id="var">$self</span>-&gt;<span id="method">value_to_xml</span><span id="braces">(</span><span id="var">$value</span>, <span id="sqStr">'anon'</span>, <span id="dqStr">"<span id="var">$indent</span>  "</span><span id="braces">)</span>,
               <span id="var">$indent</span>, <span id="sqStr">'&lt;/'</span>, <span id="var">$name</span>, <span id="dqStr">"&gt;<span id="var">$nl</span>"</span>;
      <span id="braces">}</span>
    <span id="braces">}</span>
  <span id="braces">}</span>

  <span id="perlKey">else</span> <span id="braces">{</span>
    croak <span id="dqStr">"Can't encode a value of type: "</span> . <span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span>;
  <span id="braces">}</span>


  <span id="perlFunc">pop</span> @<span id="braces">{</span><span id="var">$self</span>-&gt;<span id="braces">{</span>_ancestors<span id="braces">}</span><span id="braces">}</span> <span id="perlKey">if</span><span id="braces">(</span><span id="perlFunc">ref</span><span id="braces">(</span><span id="var">$ref</span><span id="braces">)</span><span id="braces">)</span>;

  <span id="perlKey">return</span><span id="braces">(</span><span id="perlFunc">join</span><span id="braces">(</span><span id="sqStr">''</span>, <span id="var">@result</span><span id="braces">)</span><span id="braces">)</span>;</pre>}</td></div>
<div id="sep"></div>
<a name="General" id="General"></a>
<div id="mainTitle">General documentation</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_QUICK START" id="_pod_QUICK START"></a>QUICK START</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Say you have a script called <b>foo</b> and a file of configuration options<br />called <b>foo.xml</b> containing this:<br /><pre id="podParagraph">  <config logdir="/var/log/foo/" debugfile="/tmp/foo.debug">
    <server name="sahara" osname="solaris" osversion="2.6">
      <address>10.0.0.101</address>
      <address>10.0.1.101</address>
    </server>
    <server name="gobi" osname="irix" osversion="6.5">
      <address>10.0.0.102</address>
    </server>
    <server name="kalahari" osname="linux" osversion="2.0.34">
      <address>10.0.0.103</address>
      <address>10.0.1.103</address>
    </server>
  </config>
</pre>The following lines of code in <b>foo</b>:<br /><pre id="podParagraph">  use XML::Simple;

  my $config = XMLin();
</pre>will 'slurp' the configuration options into the hashref $config (because no<br />arguments are passed to XMLin() the name and location of the XML file will<br />be inferred from name and location of the script).  You can dump out the<br />contents of the hashref using Data::Dumper:<br /><pre id="podParagraph">  use Data::Dumper;

  print Dumper($config);
</pre>which will produce something like this (formatting has been adjusted for<br />brevity):<br /><pre id="podParagraph">  {
      'logdir'        => '/var/log/foo/',
      'debugfile'     => '/tmp/foo.debug',
      'server'        => {
          'sahara'        => {
              'osversion'     => '2.6',
              'osname'        => 'solaris',
              'address'       => [ '10.0.0.101', '10.0.1.101' ]
          },
          'gobi'          => {
              'osversion'     => '6.5',
              'osname'        => 'irix',
              'address'       => '10.0.0.102'
          },
          'kalahari'      => {
              'osversion'     => '2.0.34',
              'osname'        => 'linux',
              'address'       => [ '10.0.0.103', '10.0.1.103' ]
          }
      }
  }
</pre>Your script could then access the name of the log directory like this:<br /><pre id="podParagraph">  print $config->{logdir};
</pre>similarly, the second address on the server 'kalahari' could be referenced as:<br /><pre id="podParagraph">  print $config->{server}->{kalahari}->{address}->[1];
</pre>What could be simpler?  (Rhetorical).<br />For simple requirements, that's really all there is to it.  If you want to<br />store your XML in a different directory or file, or pass it in as a string or<br />even pass it in via some derivative of an IO::Handle, you'll need to check out<br /><a href="#_pod_"OPTIONS"">"OPTIONS"</a>.  If you want to turn off or tweak the array folding feature (that<br />neat little transformation that produced $config-&gt;{server}) you'll find options<br />for that as well.<br />If you want to generate XML (for example to write a modified version of<br />$config back out as XML), check out XMLout().<br />If your needs are not so simple, this may not be the module for you.  In that<br />case, you might want to read <a href="#_pod_"WHERE TO FROM HERE?"">"WHERE TO FROM HERE?"</a>.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_OPTIONS" id="_pod_OPTIONS"></a>OPTIONS</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea"><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> supports a number of options (in fact as each release of<br /><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> adds more options, the module's claim to the name 'Simple'<br />becomes increasingly tenuous).  If you find yourself repeatedly having to<br />specify the same options, you might like to investigate <a href="#_pod_"OPTIONAL OO
INTERFACE"">"OPTIONAL OO
INTERFACE"</a> below.<br />If you can't be bothered reading the documentation, refer to<br /><a href="#_pod_"STRICT MODE"">"STRICT MODE"</a> to automatically catch common mistakes.<br />Because there are so many options, it's hard for new users to know which ones<br />are important, so here are the two you really need to know about:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;check out ForceArray because you'll almost certainly want to turn it on<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;make sure you know what the KeyAttr option does and what its default value is<br />because it may surprise you otherwise (note in particular that 'KeyAttr'<br />affects both XMLin and XMLout)<br />The option name headings below have a trailing 'comment' - a hash followed by<br />two pieces of metadata:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;Options are marked with '<i>in</i>' if they are recognised by XMLin() and<br />'<i>out</i>' if they are recognised by XMLout().<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(4)</div>&nbsp;&nbsp;&nbsp;&nbsp;Each option is also flagged to indicate whether it is:<br /><pre id="podParagraph"> 'important'   - don't use the module until you understand this one
 'handy'       - you can skip this on the first time through
 'advanced'    - you can skip this on the second time through
 'SAX only'    - don't worry about this unless you're using SAX (or
                 alternatively if you need this, you also need SAX)
 'seldom used' - you'll probably never use this unless you were the
                 person that requested the feature
</pre>The options are listed alphabetically:<br />Note: option names are no longer case sensitive so you can use the mixed case<br />versions shown here; all lower case as required by versions 2.03 and earlier;<br />or you can add underscores between the words (eg: key_attr).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_AttrIndent => 1 I<# out - handy>" id="_pod_AttrIndent => 1 I<# out - handy>"></a>AttrIndent =&gt; 1 <i># out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When you are using XMLout(), enable this option to have attributes printed<br />one-per-line with sensible indentation rather than all on one line.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_Cache => [ cache schemes ] I<# in - advanced>" id="_pod_Cache => [ cache schemes ] I<# in - advanced>"></a>Cache =&gt; [ cache schemes ] <i># in - advanced</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Because loading the <b>XML::Parser</b> module and parsing an XML file can consume a<br />significant number of CPU cycles, it is often desirable to cache the output of<br />XMLin() for later reuse.<br />When parsing from a named file, <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> supports a number of caching<br />schemes.  The 'Cache' option may be used to specify one or more schemes (using<br />an anonymous array).  Each scheme will be tried in turn in the hope of finding<br />a cached pre-parsed representation of the XML file.  If no cached copy is<br />found, the file will be parsed and the first cache scheme in the list will be<br />used to save a copy of the results.  The following cache schemes have been<br />implemented:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;storable</div>&nbsp;&nbsp;&nbsp;&nbsp;Utilises <b>Storable.pm</b> to read/write a cache file with the same name as the<br />XML file but with the extension .stor<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;memshare</div>&nbsp;&nbsp;&nbsp;&nbsp;When a file is first parsed, a copy of the resulting data structure is retained<br />in memory in the <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> module's namespace.  Subsequent calls to parse<br />the same file will return a reference to this structure.  This cached version<br />will persist only for the life of the Perl interpreter (which in the case of<br />mod_perl for example, may be some significant time).<br />&nbsp;&nbsp;&nbsp;&nbsp;Because each caller receives a reference to the same data structure, a change<br />made by one caller will be visible to all.  For this reason, the reference<br />returned should be treated as read-only.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;memcopy</div>&nbsp;&nbsp;&nbsp;&nbsp;This scheme works identically to 'memshare' (above) except that each caller<br />receives a reference to a new data structure which is a copy of the cached<br />version.  Copying the data structure will add a little processing overhead,<br />therefore this scheme should only be used where the caller intends to modify<br />the data structure (or wishes to protect itself from others who might).  This<br />scheme uses <b>Storable.pm</b> to perform the copy.<br />Warning! The memory-based caching schemes compare the timestamp on the file to<br />the time when it was last parsed.  If the file is stored on an NFS filesystem<br />(or other network share) and the clock on the file server is not exactly<br />synchronised with the clock where your script is run, updates to the source XML<br />file may appear to be ignored.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ContentKey => 'keyname' I<# in+out - seldom used>" id="_pod_ContentKey => 'keyname' I<# in+out - seldom used>"></a>ContentKey =&gt; 'keyname' <i># in+out - seldom used</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When text content is parsed to a hash value, this option let's you specify a<br />name for the hash key to override the default 'content'.  So for example:<br /><pre id="podParagraph">  XMLin('<opt one="1">Text</opt>', ContentKey => 'text')
</pre>will parse to:<br /><pre id="podParagraph">  { 'one' => 1, 'text' => 'Text' }
</pre>instead of:<br /><pre id="podParagraph">  { 'one' => 1, 'content' => 'Text' }
</pre>XMLout() will also honour the value of this option when converting a hashref<br />to XML.<br />You can also prefix your selected key name with a '-' character to have <br />XMLin() try a little harder to eliminate unnecessary 'content' keys after<br />array folding.  For example:<br /><pre id="podParagraph">  XMLin(
    '<opt><item name="one">First</item><item name="two">Second</item></opt>', 
    KeyAttr => {item => 'name'}, 
    ForceArray => [ 'item' ],
    ContentKey => '-content'
  )
</pre>will parse to:<br /><pre id="podParagraph">  {
    'item' => {
      'one' =>  'First'
      'two' =>  'Second'
    }
  }
</pre>rather than this (without the '-'):<br /><pre id="podParagraph">  {
    'item' => {
      'one' => { 'content' => 'First' }
      'two' => { 'content' => 'Second' }
    }
  }</pre></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_DataHandler => code_ref I<# in - SAX only>" id="_pod_DataHandler => code_ref I<# in - SAX only>"></a>DataHandler =&gt; code_ref <i># in - SAX only</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When you use an <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> object as a SAX handler, it will return a<br />'simple tree' data structure in the same format as XMLin() would return.  If<br />this option is set (to a subroutine reference), then when the tree is built the<br />subroutine will be called and passed two arguments: a reference to the<br /><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> object and a reference to the data tree.  The return value from<br />the subroutine will be returned to the SAX driver.  (See <a href="#_pod_"SAX SUPPORT"">"SAX SUPPORT"</a> for<br />more details).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ForceArray => 1 I<# in - important>" id="_pod_ForceArray => 1 I<# in - important>"></a>ForceArray =&gt; 1 <i># in - important</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option should be set to '1' to force nested elements to be represented<br />as arrays even when there is only one.  Eg, with ForceArray enabled, this<br />XML:<br /><pre id="podParagraph">    <opt>
      <name>value</name>
    </opt>
</pre>would parse to this:<br /><pre id="podParagraph">    {
      'name' => [
                  'value'
                ]
    }
</pre>instead of this (the default):<br /><pre id="podParagraph">    {
      'name' => 'value'
    }
</pre>This option is especially useful if the data structure is likely to be written<br />back out as XML and the default behaviour of rolling single nested elements up<br />into attributes is not desirable. <br />If you are using the array folding feature, you should almost certainly enable<br />this option.  If you do not, single nested elements will not be parsed to<br />arrays and therefore will not be candidates for folding to a hash.  (Given that<br />the default value of 'KeyAttr' enables array folding, the default value of this<br />option should probably also have been enabled too - sorry).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ForceArray => [ names ] I<# in - important>" id="_pod_ForceArray => [ names ] I<# in - important>"></a>ForceArray =&gt; [ names ] <i># in - important</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This alternative (and preferred) form of the 'ForceArray' option allows you to<br />specify a list of element names which should always be forced into an array<br />representation, rather than the 'all or nothing' approach above.<br />It is also possible (since version 2.05) to include compiled regular<br />expressions in the list - any element names which match the pattern will be<br />forced to arrays.  If the list contains only a single regex, then it is not<br />necessary to enclose it in an arrayref.  Eg:<br /><pre id="podParagraph">  ForceArray => qr/_list$/</pre></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ForceContent => 1 I<# in - seldom used>" id="_pod_ForceContent => 1 I<# in - seldom used>"></a>ForceContent =&gt; 1 <i># in - seldom used</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When XMLin() parses elements which have text content as well as attributes,<br />the text content must be represented as a hash value rather than a simple<br />scalar.  This option allows you to force text content to always parse to<br />a hash value even when there are no attributes.  So for example:<br /><pre id="podParagraph">  XMLin('<opt><x>text1</x><y a="2">text2</y></opt>', ForceContent => 1)
</pre>will parse to:<br /><pre id="podParagraph">  {
    'x' => {           'content' => 'text1' },
    'y' => { 'a' => 2, 'content' => 'text2' }
  }
</pre>instead of:<br /><pre id="podParagraph">  {
    'x' => 'text1',
    'y' => { 'a' => 2, 'content' => 'text2' }
  }</pre></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_GroupTags => { grouping tag => grouped tag } I<# in+out - handy>" id="_pod_GroupTags => { grouping tag => grouped tag } I<# in+out - handy>"></a>GroupTags =&gt; { grouping tag =&gt; grouped tag } <i># in+out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">You can use this option to eliminate extra levels of indirection in your Perl<br />data structure.  For example this XML:<br /><pre id="podParagraph">  <opt>
   <searchpath>
     <dir>/usr/bin</dir>
     <dir>/usr/local/bin</dir>
     <dir>/usr/X11/bin</dir>
   </searchpath>
 </opt>
</pre>Would normally be read into a structure like this:<br /><pre id="podParagraph">  {
    searchpath => {
                    dir => [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
                  }
  }
</pre>But when read in with the appropriate value for 'GroupTags':<br /><pre id="podParagraph">  my $opt = XMLin($xml, GroupTags => { searchpath => 'dir' });
</pre>It will return this simpler structure:<br /><pre id="podParagraph">  {
    searchpath => [ '/usr/bin', '/usr/local/bin', '/usr/X11/bin' ]
  }
</pre>The grouping element (&lt; &lt;searchpath&gt; &gt; in the example) must not contain any<br />attributes or elements other than the grouped element.<br />You can specify multiple 'grouping element' to 'grouped element' mappings in<br />the same hashref.  If this option is combined with KeyAttr, the array<br />folding will occur first and then the grouped element names will be eliminated.<br />XMLout will also use the grouptag mappings to re-introduce the tags around<br />the grouped elements.  Beware though that this will occur in all places that<br />the 'grouping tag' name occurs - you probably don't want to use the same name<br />for elements as well as attributes.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_Handler => object_ref I<# out - SAX only>" id="_pod_Handler => object_ref I<# out - SAX only>"></a>Handler =&gt; object_ref <i># out - SAX only</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Use the 'Handler' option to have XMLout() generate SAX events rather than <br />returning a string of XML.  For more details see <a href="#_pod_"SAX SUPPORT"">"SAX SUPPORT"</a> below.<br />Note: the current implementation of this option generates a string of XML<br />and uses a SAX parser to translate it into SAX events.  The normal encoding<br />rules apply here - your data must be UTF8 encoded unless you specify an <br />alternative encoding via the 'XMLDecl' option; and by the time the data reaches<br />the handler object, it will be in UTF8 form regardless of the encoding you<br />supply.  A future implementation of this option may generate the events <br />directly.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_KeepRoot => 1 I<# in+out - handy>" id="_pod_KeepRoot => 1 I<# in+out - handy>"></a>KeepRoot =&gt; 1 <i># in+out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">In its attempt to return a data structure free of superfluous detail and<br />unnecessary levels of indirection, XMLin() normally discards the root<br />element name.  Setting the 'KeepRoot' option to '1' will cause the root element<br />name to be retained.  So after executing this code:<br /><pre id="podParagraph">  $config = XMLin('<config tempdir="/tmp" />', KeepRoot => 1)
</pre>You'll be able to reference the tempdir as<br />$config-E&lt;gt&gt;{config}-E&lt;gt&gt;{tempdir} instead of the default<br />$config-E&lt;gt&gt;{tempdir}.<br />Similarly, setting the 'KeepRoot' option to '1' will tell XMLout() that the<br />data structure already contains a root element name and it is not necessary to<br />add another.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_KeyAttr => [ list ] I<# in+out - important>" id="_pod_KeyAttr => [ list ] I<# in+out - important>"></a>KeyAttr =&gt; [ list ] <i># in+out - important</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option controls the 'array folding' feature which translates nested<br />elements from an array to a hash.  It also controls the 'unfolding' of hashes<br />to arrays.<br />For example, this XML:<br /><pre id="podParagraph">    <opt>
      <user login="grep" fullname="Gary R Epstein" />
      <user login="stty" fullname="Simon T Tyson" />
    </opt>
</pre>would, by default, parse to this:<br /><pre id="podParagraph">    {
      'user' => [
                  {
                    'login' => 'grep',
                    'fullname' => 'Gary R Epstein'
                  },
                  {
                    'login' => 'stty',
                    'fullname' => 'Simon T Tyson'
                  }
                ]
    }
</pre>If the option 'KeyAttr =&gt; &quot;login&quot;' were used to specify that the 'login'<br />attribute is a key, the same XML would parse to:<br /><pre id="podParagraph">    {
      'user' => {
                  'stty' => {
                              'fullname' => 'Simon T Tyson'
                            },
                  'grep' => {
                              'fullname' => 'Gary R Epstein'
                            }
                }
    }
</pre>The key attribute names should be supplied in an arrayref if there is more<br />than one.  XMLin() will attempt to match attribute names in the order<br />supplied.  XMLout() will use the first attribute name supplied when<br />'unfolding' a hash into an array.<br />Note 1: The default value for 'KeyAttr' is ['name', 'key', 'id'].  If you do<br />not want folding on input or unfolding on output you must setting this option<br />to an empty list to disable the feature.<br />Note 2: If you wish to use this option, you should also enable the<br />ForceArray option.  Without 'ForceArray', a single nested element will be<br />rolled up into a scalar rather than an array and therefore will not be folded<br />(since only arrays get folded).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_KeyAttr => { list } I<# in+out - important>" id="_pod_KeyAttr => { list } I<# in+out - important>"></a>KeyAttr =&gt; { list } <i># in+out - important</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This alternative (and preferred) method of specifiying the key attributes<br />allows more fine grained control over which elements are folded and on which<br />attributes.  For example the option 'KeyAttr =&gt; { package =&gt; 'id' } will cause<br />any package elements to be folded on the 'id' attribute.  No other elements<br />which have an 'id' attribute will be folded at all. <br />Note: XMLin() will generate a warning (or a fatal error in <a href="#_pod_"STRICT MODE"">"STRICT MODE"</a>)<br />if this syntax is used and an element which does not have the specified key<br />attribute is encountered (eg: a 'package' element without an 'id' attribute, to<br />use the example above).  Warnings will only be generated if <b>-w</b> is in force.<br />Two further variations are made possible by prefixing a '+' or a '-' character<br />to the attribute name:<br />The option 'KeyAttr =&gt; { user =&gt; &quot;+login&quot; }' will cause this XML:<br /><pre id="podParagraph">    <opt>
      <user login="grep" fullname="Gary R Epstein" />
      <user login="stty" fullname="Simon T Tyson" />
    </opt>
</pre>to parse to this data structure:<br /><pre id="podParagraph">    {
      'user' => {
                  'stty' => {
                              'fullname' => 'Simon T Tyson',
                              'login'    => 'stty'
                            },
                  'grep' => {
                              'fullname' => 'Gary R Epstein',
                              'login'    => 'grep'
                            }
                }
    }
</pre>The '+' indicates that the value of the key attribute should be copied rather<br />than moved to the folded hash key.<br />A '-' prefix would produce this result:<br /><pre id="podParagraph">    {
      'user' => {
                  'stty' => {
                              'fullname' => 'Simon T Tyson',
                              '-login'    => 'stty'
                            },
                  'grep' => {
                              'fullname' => 'Gary R Epstein',
                              '-login'    => 'grep'
                            }
                }
    }
</pre>As described earlier, XMLout will ignore hash keys starting with a '-'.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NoAttr => 1 I<# in+out - handy>" id="_pod_NoAttr => 1 I<# in+out - handy>"></a>NoAttr =&gt; 1 <i># in+out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When used with XMLout(), the generated XML will contain no attributes.<br />All hash key/values will be represented as nested elements instead.<br />When used with XMLin(), any attributes in the XML will be ignored.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NoEscape => 1 I<# out - seldom used>" id="_pod_NoEscape => 1 I<# out - seldom used>"></a>NoEscape =&gt; 1 <i># out - seldom used</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">By default, XMLout() will translate the characters '&lt;', '&gt;', '&amp;' and<br />'&quot;' to '&amp;lt;', '&amp;gt;', '&amp;amp;' and '&amp;quot' respectively.  Use this option to<br />suppress escaping (presumably because you've already escaped the data in some<br />more sophisticated manner).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NoIndent => 1 I<# out - seldom used>" id="_pod_NoIndent => 1 I<# out - seldom used>"></a>NoIndent =&gt; 1 <i># out - seldom used</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Set this option to 1 to disable XMLout()'s default 'pretty printing' mode.<br />With this option enabled, the XML output will all be on one line (unless there<br />are newlines in the data) - this may be easier for downstream processing.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NoSort => 1 I<# out - seldom used>" id="_pod_NoSort => 1 I<# out - seldom used>"></a>NoSort =&gt; 1 <i># out - seldom used</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Newer versions of <B>XML::Simple</B> sort elements and attributes alphabetically (*),<br />by default.  Enable this option to suppress the sorting - possibly for<br />backwards compatibility.<br />* Actually, sorting is alphabetical but 'key' attribute or element names (as in<br />'KeyAttr') sort first.  Also, when a hash of hashes is 'unfolded', the elements<br />are sorted alphabetically by the value of the key field.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NormaliseSpace => 0 | 1 | 2 I<# in - handy>" id="_pod_NormaliseSpace => 0 | 1 | 2 I<# in - handy>"></a>NormaliseSpace =&gt; 0 | 1 | 2 <i># in - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option controls how whitespace in text content is handled.  Recognised<br />values for the option are:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;0 = (default) whitespace is passed through unaltered (except of course for the<br />normalisation of whitespace in attribute values which is mandated by the XML<br />recommendation)<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;1 = whitespace is normalised in any value used as a hash key (normalising means<br />removing leading and trailing whitespace and collapsing sequences of whitespace<br />characters to a single space)<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;2 = whitespace is normalised in all text content<br />Note: you can spell this option with a 'z' if that is more natural for you.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NSExpand => 1 I<# in+out handy - SAX only>" id="_pod_NSExpand => 1 I<# in+out handy - SAX only>"></a>NSExpand =&gt; 1 <i># in+out handy - SAX only</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option controls namespace expansion - the translation of element and<br />attribute names of the form 'prefix:name' to '{uri}name'.  For example the<br />element name 'xsl:template' might be expanded to:<br />'{<a href="http://www.w3.org/1999/XSL/Transform}template" target="urlWin" id="podUrl">http://www.w3.org/1999/XSL/Transform}template</a>'.<br />By default, XMLin() will return element names and attribute names exactly as<br />they appear in the XML.  Setting this option to 1 will cause all element and<br />attribute names to be expanded to include their namespace prefix.<br /><i>Note: You must be using a SAX parser for this option to work (ie: it does not<br />work with XML::Parser)</i>.<br />This option also controls whether XMLout() performs the reverse translation<br />from '{uri}name' back to 'prefix:name'.  The default is no translation.  If<br />your data contains expanded names, you should set this option to 1 otherwise<br />XMLout will emit XML which is not well formed.<br /><i>Note: You must have the XML::NamespaceSupport module installed if you want<br />C&lt;XMLout()&gt; to translate URIs back to prefixes</i>.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_NumericEscape => 0 | 1 | 2 I<# out - handy>" id="_pod_NumericEscape => 0 | 1 | 2 I<# out - handy>"></a>NumericEscape =&gt; 0 | 1 | 2 <i># out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Use this option to have 'high' (non-ASCII) characters in your Perl data<br />structure converted to numeric entities (eg: &amp;#8364;) in the XML output.  Three<br />levels are possible:<br />0 - default: no numeric escaping (OK if you're writing out UTF8)<br />1 - only characters above 0xFF are escaped (ie: characters in the 0x80-FF range are not escaped), possibly useful with ISO8859-1 output<br />2 - all characters above 0x7F are escaped (good for plain ASCII output)</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_OutputFile => <file specifier> I<# out - handy>" id="_pod_OutputFile => <file specifier> I<# out - handy>"></a>OutputFile =&gt; &lt;file specifier&gt; <i># out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">The default behaviour of XMLout() is to return the XML as a string.  If you<br />wish to write the XML to a file, simply supply the filename using the<br />'OutputFile' option.  <br />This option also accepts an IO handle object - especially useful in Perl 5.8.0 <br />and later for output using an encoding other than UTF-8, eg:<br /><pre id="podParagraph">  open my $fh, '>:encoding(iso-8859-1)', $path or die "open($path): $!";
  XMLout($ref, OutputFile => $fh);
</pre>Note, <B>XML::Simple</B> does not require that the object you pass in to the<br />OutputFile option inherits from <a href="#_pod_IO::Handle">IO::Handle</a> - it simply assumes the object<br />supports a print method.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ParserOpts => [ XML::Parser Options ] I<# in - don't use this>" id="_pod_ParserOpts => [ XML::Parser Options ] I<# in - don't use this>"></a>ParserOpts =&gt; [ XML::Parser Options ] <i># in - don't use this</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea"><i>Note: This option is now officially deprecated.  If you find it useful, email<br />the author with an example of what you use it for.  Do not use this option to<br />set the ProtocolEncoding, that's just plain wrong - fix the XML</i>.<br />This option allows you to pass parameters to the constructor of the underlying<br />XML::Parser object (which of course assumes you're not using SAX).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_RootName => 'string' I<# out - handy>" id="_pod_RootName => 'string' I<# out - handy>"></a>RootName =&gt; 'string' <i># out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">By default, when XMLout() generates XML, the root element will be named<br />'opt'.  This option allows you to specify an alternative name.<br />Specifying either undef or the empty string for the RootName option will<br />produce XML with no root elements.  In most cases the resulting XML fragment<br />will not be 'well formed' and therefore could not be read back in by XMLin().<br />Nevertheless, the option has been found to be useful in certain circumstances.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_SearchPath => [ list ] I<# in - handy>" id="_pod_SearchPath => [ list ] I<# in - handy>"></a>SearchPath =&gt; [ list ] <i># in - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">If you pass XMLin() a filename, but the filename include no directory<br />component, you can use this option to specify which directories should be<br />searched to locate the file.  You might use this option to search first in the<br />user's home directory, then in a global directory such as /etc.<br />If a filename is provided to XMLin() but SearchPath is not defined, the<br />file is assumed to be in the current directory.<br />If the first parameter to XMLin() is undefined, the default SearchPath<br />will contain only the directory in which the script itself is located.<br />Otherwise the default SearchPath will be empty.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_SuppressEmpty => 1 | '' | undef I<# in+out - handy>" id="_pod_SuppressEmpty => 1 | '' | undef I<# in+out - handy>"></a>SuppressEmpty =&gt; 1 | '' | undef <i># in+out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option controls what XMLin() should do with empty elements (no<br />attributes and no content).  The default behaviour is to represent them as<br />empty hashes.  Setting this option to a true value (eg: 1) will cause empty<br />elements to be skipped altogether.  Setting the option to 'undef' or the empty<br />string will cause empty elements to be represented as the undefined value or<br />the empty string respectively.  The latter two alternatives are a little<br />easier to test for in your code than a hash with no keys.<br />The option also controls what XMLout() does with undefined values.  Setting<br />the option to undef causes undefined values to be output as empty elements<br />(rather than empty attributes), it also suppresses the generation of warnings<br />about undefined values.  Setting the option to a true value (eg: 1) causes<br />undefined values to be skipped altogether on output.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ValueAttr => [ names ] I<# in - handy>" id="_pod_ValueAttr => [ names ] I<# in - handy>"></a>ValueAttr =&gt; [ names ] <i># in - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Use this option to deal elements which always have a single attribute and no<br />content.  Eg:<br /><pre id="podParagraph">  <opt>
    <colour value="red" />
    <size   value="XXL" />
  </opt>
</pre>Setting &lt; ValueAttr =&gt; [ 'value' ] &gt; will cause the above XML to parse to:<br /><pre id="podParagraph">  {
    colour => 'red',
    size   => 'XXL'
  }
</pre>instead of this (the default):<br /><pre id="podParagraph">  {
    colour => { value => 'red' },
    size   => { value => 'XXL' }
  }
</pre>Note: This form of the ValueAttr option is not compatible with XMLout() -<br />since the attribute name is discarded at parse time, the original XML cannot be<br />reconstructed.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ValueAttr => { element => attribute, ... } I<# in+out - handy>" id="_pod_ValueAttr => { element => attribute, ... } I<# in+out - handy>"></a>ValueAttr =&gt; { element =&gt; attribute, ... } <i># in+out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This (preferred) form of the ValueAttr option requires you to specify both<br />the element and the attribute names.  This is not only safer, it also allows<br />the original XML to be reconstructed by XMLout().<br />Note: You probably don't want to use this option and the NoAttr option at the<br />same time.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_Variables => { name => value } I<# in - handy>" id="_pod_Variables => { name => value } I<# in - handy>"></a>Variables =&gt; { name =&gt; value } <i># in - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">This option allows variables in the XML to be expanded when the file is read.<br />(there is no facility for putting the variable names back if you regenerate<br />XML using XMLout).<br />A 'variable' is any text of the form ${name} which occurs in an attribute<br />value or in the text content of an element.  If 'name' matches a key in the<br />supplied hashref, ${name} will be replaced with the corresponding value from<br />the hashref.  If no matching key is found, the variable will not be replaced.<br />Names must match the regex: [\w.]+ (ie: only 'word' characters and dots are<br />allowed).</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_VarAttr => 'attr_name' I<# in - handy>" id="_pod_VarAttr => 'attr_name' I<# in - handy>"></a>VarAttr =&gt; 'attr_name' <i># in - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">In addition to the variables defined using Variables, this option allows<br />variables to be defined in the XML.  A variable definition consists of an<br />element with an attribute called 'attr_name' (the value of the VarAttr<br />option).  The value of the attribute will be used as the variable name and the<br />text content of the element will be used as the value.  A variable defined in<br />this way will override a variable defined using the Variables option.  For<br />example:<br /><pre id="podParagraph">  XMLin( '<opt>
            <dir name="prefix">/usr/local/apache</dir>
            <dir name="exec_prefix">${prefix}</dir>
            <dir name="bindir">${exec_prefix}/bin</dir>
          </opt>',
         VarAttr => 'name', ContentKey => '-content'
        );
</pre>produces the following data structure:<br /><pre id="podParagraph">  {
    dir => {
             prefix      => '/usr/local/apache',
             exec_prefix => '/usr/local/apache',
             bindir      => '/usr/local/apache/bin',
           }
  }</pre></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_XMLDecl => 1  or  XMLDecl => 'string'  I<# out - handy>" id="_pod_XMLDecl => 1  or  XMLDecl => 'string'  I<# out - handy>"></a>XMLDecl =&gt; 1  or  XMLDecl =&gt; 'string'  <i># out - handy</i></td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">If you want the output from XMLout() to start with the optional XML<br />declaration, simply set the option to '1'.  The default XML declaration is:<br /><pre id="podParagraph">        <?xml version='1.0' standalone='yes'?>
</pre>If you want some other string (for example to declare an encoding value), set<br />the value of this option to the complete string you require.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_OPTIONAL OO INTERFACE" id="_pod_OPTIONAL OO INTERFACE"></a>OPTIONAL OO INTERFACE</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">The procedural interface is both simple and convenient however there are a<br />couple of reasons why you might prefer to use the object oriented (OO)<br />interface:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;to define a set of default values which should be used on all subsequent calls<br />to XMLin() or XMLout()<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;to override methods in <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> to provide customised behaviour<br />The default values for the options described above are unlikely to suit<br />everyone.  The OO interface allows you to effectively override <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a>'s<br />defaults with your preferred values.  It works like this:<br />First create an <B>XML::Simple</B> parser object with your preferred defaults:<br /><pre id="podParagraph">  my $xs = <B>XML::Simple</B>->new(ForceArray => 1, KeepRoot => 1);
</pre>then call XMLin() or XMLout() as a method of that object:<br /><pre id="podParagraph">  my $ref = $xs->XMLin($xml);
  my $xml = $xs->XMLout($ref);
</pre>You can also specify options when you make the method calls and these values<br />will be merged with the values specified when the object was created.  Values<br />specified in a method call take precedence.<br />Overriding methods is a more advanced topic but might be useful if for example<br />you wished to provide an alternative routine for escaping character data (the<br />escape_value method) or for building the initial parse tree (the build_tree<br />method).<br />Note: when called as methods, the XMLin() and XMLout() routines may be<br />called as xml_in() or xml_out().  The method names are aliased so the<br />only difference is the aesthetics.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_STRICT MODE" id="_pod_STRICT MODE"></a>STRICT MODE</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">If you import the <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> routines like this:<br /><pre id="podParagraph">  use <B>XML::Simple</B> qw(:strict);
</pre>the following common mistakes will be detected and treated as fatal errors<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;Failing to explicitly set the KeyAttr option - if you can't be bothered<br />reading about this option, turn it off with: KeyAttr =&gt; [ ]<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;Failing to explicitly set the ForceArray option - if you can't be bothered<br />reading about this option, set it to the safest mode with: ForceArray =&gt; 1<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;Setting ForceArray to an array, but failing to list all the elements from the<br />KeyAttr hash.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(4)</div>&nbsp;&nbsp;&nbsp;&nbsp;Data error - KeyAttr is set to say { part =&gt; 'partnum' } but the XML contains<br />one or more &lt;part&gt; elements without a 'partnum' attribute (or nested<br />element).  Note: if strict mode is not set but -w is, this condition triggers a<br />warning.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;* </div>&nbsp;&nbsp;&nbsp;&nbsp;Data error - as above, but value of key attribute (eg: partnum) is not a <br />scalar string (due to nested elements etc).  This will also trigger a warning<br />if strict mode is not enabled.<br /></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_SAX SUPPORT" id="_pod_SAX SUPPORT"></a>SAX SUPPORT</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">From version 1.08_01, <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> includes support for SAX (the Simple API<br />for XML) - specifically SAX2. <br />In a typical SAX application, an XML parser (or SAX 'driver') module generates<br />SAX events (start of element, character data, end of element, etc) as it parses<br />an XML document and a 'handler' module processes the events to extract the<br />required data.  This simple model allows for some interesting and powerful<br />possibilities:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;Applications written to the SAX API can extract data from huge XML documents<br />without the memory overheads of a DOM or tree API.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;The SAX API allows for plug and play interchange of parser modules without<br />having to change your code to fit a new module's API.  A number of SAX parsers<br />are available with capabilities ranging from extreme portability to blazing<br />performance.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;A SAX 'filter' module can implement both a handler interface for receiving<br />data and a generator interface for passing modified data on to a downstream<br />handler.  Filters can be chained together in 'pipelines'.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(4)</div>&nbsp;&nbsp;&nbsp;&nbsp;One filter module might split a data stream to direct data to two or more<br />downstream handlers.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(5)</div>&nbsp;&nbsp;&nbsp;&nbsp;Generating SAX events is not the exclusive preserve of XML parsing modules.<br />For example, a module might extract data from a relational database using DBI<br />and pass it on to a SAX pipeline for filtering and formatting.<br /><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> can operate at either end of a SAX pipeline.  For example,<br />you can take a data structure in the form of a hashref and pass it into a<br />SAX pipeline using the 'Handler' option on XMLout():<br /><pre id="podParagraph">  use XML::Simple;
  use Some::SAX::Filter;
  use XML::SAX::Writer;

  my $ref = {
               ....   # your data here
            };

  my $writer = XML::SAX::Writer->new();
  my $filter = Some::SAX::Filter->new(Handler => $writer);
  my $simple = <B>XML::Simple</B>->new(Handler => $filter);
  $simple->XMLout($ref);
</pre>You can also put <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> at the opposite end of the pipeline to take<br />advantage of the simple 'tree' data structure once the relevant data has been<br />isolated through filtering:<br /><pre id="podParagraph">  use XML::SAX;
  use Some::SAX::Filter;
  use XML::Simple;

  my $simple = <B>XML::Simple</B>->new(ForceArray => 1, KeyAttr => ['partnum']);
  my $filter = Some::SAX::Filter->new(Handler => $simple);
  my $parser = XML::SAX::ParserFactory->parser(Handler => $filter);

  my $ref = $parser->parse_uri('some_huge_file.xml');

  print $ref->{part}->{'555-1234'};
</pre>You can build a filter by using an <B>XML::Simple</B> object as a handler and setting<br />its DataHandler option to point to a routine which takes the resulting tree,<br />modifies it and sends it off as SAX events to a downstream handler:<br /><pre id="podParagraph">  my $writer = XML::SAX::Writer->new();
  my $filter = <B>XML::Simple</B>->new(
                 DataHandler => sub {
                                  my $simple = shift;
                                  my $data = shift;

                                  # Modify $data here

                                  $simple->XMLout($data, Handler => $writer);
                                }
               );
  my $parser = XML::SAX::ParserFactory->parser(Handler => $filter);

  $parser->parse_uri($filename);
</pre><i>Note: In this last example, the 'Handler' option was specified in the call to<br />C&lt;XMLout()&gt; but it could also have been specified in the constructor</i>.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ENVIRONMENT" id="_pod_ENVIRONMENT"></a>ENVIRONMENT</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">If you don't care which parser module <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> uses then skip this<br />section entirely (it looks more complicated than it really is).<br /><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> will default to using a <b>SAX</b> parser if one is available or<br /><b>XML::Parser</b> if SAX is not available.<br />You can dictate which parser module is used by setting either the environment<br />variable 'XML_SIMPLE_PREFERRED_PARSER' or the package variable<br />$XML::Simple::PREFERRED_PARSER to contain the module name.  The following rules<br />are used:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;The package variable takes precedence over the environment variable if both are defined.  To force <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> to ignore the environment settings and use<br />its default rules, you can set the package variable to an empty string.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;If the 'preferred parser' is set to the string 'XML::Parser', then<br /><a href="#_pod_XML::Parser">XML::Parser</a> will be used (or XMLin() will die if <a href="#_pod_XML::Parser">XML::Parser</a> is not<br />installed).<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;* </div>&nbsp;&nbsp;&nbsp;&nbsp;If the 'preferred parser' is set to some other value, then it is assumed to be<br />the name of a SAX parser module and is passed to <a href="#_pod_XML::SAX::ParserFactory.">XML::SAX::ParserFactory.</a><br />If <a href="#_pod_XML::SAX">XML::SAX</a> is not installed, or the requested parser module is not<br />installed, then XMLin() will die.<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;If the 'preferred parser' is not defined at all (the normal default<br />state), an attempt will be made to load <a href="#_pod_XML::SAX">XML::SAX</a>.  If <a href="#_pod_XML::SAX">XML::SAX</a> is<br />installed, then a parser module will be selected according to<br /><a href="#_pod_XML::SAX::ParserFactory">XML::SAX::ParserFactory</a>'s normal rules (which typically means the last SAX<br />parser installed).<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(4)</div>&nbsp;&nbsp;&nbsp;&nbsp;if the 'preferred parser' is not defined and <b>XML::SAX</b> is not<br />installed, then <b>XML::Parser</b> will be used.  XMLin() will die if<br /><a href="#_pod_XML::Parser">XML::Parser</a> is not installed.<br />Note: The <b>XML::SAX</b> distribution includes an XML parser written entirely in<br />Perl.  It is very portable but it is not very fast.  You should consider<br />installing <a href="#_pod_XML::LibXML">XML::LibXML</a> or <a href="#_pod_XML::SAX::Expat">XML::SAX::Expat</a> if they are available for your<br />platform.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_ERROR HANDLING" id="_pod_ERROR HANDLING"></a>ERROR HANDLING</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">The XML standard is very clear on the issue of non-compliant documents.  An<br />error in parsing any single element (for example a missing end tag) must cause<br />the whole document to be rejected.  <a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> will die with an appropriate<br />message if it encounters a parsing error.<br />If dying is not appropriate for your application, you should arrange to call<br />XMLin() in an eval block and look for errors in $@.  eg:<br /><pre id="podParagraph">    my $config = eval { XMLin() };
    PopUpMessage($@) if($@);
</pre>Note, there is a common misconception that use of <b>eval</b> will significantly<br />slow down a script.  While that may be true when the code being eval'd is in a<br />string, it is not true of code like the sample above.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_EXAMPLES" id="_pod_EXAMPLES"></a>EXAMPLES</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">When XMLin() reads the following very simple piece of XML:<br /><pre id="podParagraph">    <opt username="testuser" password="frodo"></opt>
</pre>it returns the following data structure:<br /><pre id="podParagraph">    {
      'username' => 'testuser',
      'password' => 'frodo'
    }
</pre>The identical result could have been produced with this alternative XML:<br /><pre id="podParagraph">    <opt username="testuser" password="frodo" />
</pre>Or this (although see 'ForceArray' option for variations):<br /><pre id="podParagraph">    <opt>
      <username>testuser</username>
      <password>frodo</password>
    </opt>
</pre>Repeated nested elements are represented as anonymous arrays:<br /><pre id="podParagraph">    <opt>
      <person firstname="Joe" lastname="Smith">
        <email><a href="mailto:joe@smith.com" id="podEmail">joe@smith.com</a>&lt;/email&gt;<br />        &lt;email&gt;<a href="mailto:jsmith@yahoo.com" id="podEmail">jsmith@yahoo.com</a>&lt;/email&gt;<br />      &lt;/person&gt;<br />      &lt;person firstname=&quot;Bob&quot; lastname=&quot;Smith&quot;&gt;<br />        &lt;email&gt;<a href="mailto:bob@smith.com" id="podEmail">bob@smith.com</a>&lt;/email&gt;<br />      &lt;/person&gt;<br />    &lt;/opt&gt;<br />
    {
      'person' => [
                    {
                      'email' => [
                                   '<a href="mailto:joe@smith.com" id="podEmail">joe@smith.com</a>',<br />                                   '<a href="mailto:jsmith@yahoo.com" id="podEmail">jsmith@yahoo.com</a>'<br />                                 ],<br />                      'firstname' =&gt; 'Joe',<br />                      'lastname' =&gt; 'Smith'<br />                    },<br />                    {<br />                      'email' =&gt; '<a href="mailto:bob@smith.com" id="podEmail">bob@smith.com</a>',<br />                      'firstname' =&gt; 'Bob',<br />                      'lastname' =&gt; 'Smith'<br />                    }<br />                  ]<br />    }<br /></pre>Nested elements with a recognised key attribute are transformed (folded) from<br />an array into a hash keyed on the value of that attribute (see the KeyAttr<br />option):<br /><pre id="podParagraph">    <opt>
      <person key="jsmith" firstname="Joe" lastname="Smith" />
      <person key="tsmith" firstname="Tom" lastname="Smith" />
      <person key="jbloggs" firstname="Joe" lastname="Bloggs" />
    </opt>

    {
      'person' => {
                    'jbloggs' => {
                                   'firstname' => 'Joe',
                                   'lastname' => 'Bloggs'
                                 },
                    'tsmith' => {
                                  'firstname' => 'Tom',
                                  'lastname' => 'Smith'
                                },
                    'jsmith' => {
                                  'firstname' => 'Joe',
                                  'lastname' => 'Smith'
                                }
                  }
    }
</pre>The &lt;anon&gt; tag can be used to form anonymous arrays:<br /><pre id="podParagraph">    <opt>
      <head><anon>Col 1</anon><anon>Col 2</anon><anon>Col 3</anon></head>
      <data><anon>R1C1</anon><anon>R1C2</anon><anon>R1C3</anon></data>
      <data><anon>R2C1</anon><anon>R2C2</anon><anon>R2C3</anon></data>
      <data><anon>R3C1</anon><anon>R3C2</anon><anon>R3C3</anon></data>
    </opt>

    {
      'head' => [
                  [ 'Col 1', 'Col 2', 'Col 3' ]
                ],
      'data' => [
                  [ 'R1C1', 'R1C2', 'R1C3' ],
                  [ 'R2C1', 'R2C2', 'R2C3' ],
                  [ 'R3C1', 'R3C2', 'R3C3' ]
                ]
    }
</pre>Anonymous arrays can be nested to arbirtrary levels and as a special case, if<br />the surrounding tags for an XML document contain only an anonymous array the<br />arrayref will be returned directly rather than the usual hashref:<br /><pre id="podParagraph">    <opt>
      <anon><anon>Col 1</anon><anon>Col 2</anon></anon>
      <anon><anon>R1C1</anon><anon>R1C2</anon></anon>
      <anon><anon>R2C1</anon><anon>R2C2</anon></anon>
    </opt>

    [
      [ 'Col 1', 'Col 2' ],
      [ 'R1C1', 'R1C2' ],
      [ 'R2C1', 'R2C2' ]
    ]
</pre>Elements which only contain text content will simply be represented as a<br />scalar.  Where an element has both attributes and text content, the element<br />will be represented as a hashref with the text content in the 'content' key<br />(see the ContentKey option):<br /><pre id="podParagraph">  <opt>
    <one>first</one>
    <two attr="value">second</two>
  </opt>

  {
    'one' => 'first',
    'two' => { 'attr' => 'value', 'content' => 'second' }
  }
</pre>Mixed content (elements which contain both text content and nested elements)<br />will be not be represented in a useful way - element order and significant<br />whitespace will be lost.  If you need to work with mixed content, then<br /><B>XML::Simple</B> is not the right tool for your job - check out the next section.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_WHERE TO FROM HERE?" id="_pod_WHERE TO FROM HERE?"></a>WHERE TO FROM HERE?</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea"><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> is able to present a simple API because it makes some<br />assumptions on your behalf.  These include:<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(1)</div>&nbsp;&nbsp;&nbsp;&nbsp;You're not interested in text content consisting only of whitespace<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;* </div>&nbsp;&nbsp;&nbsp;&nbsp;You don't mind that when things get slurped into a hash the order is lost<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(2)</div>&nbsp;&nbsp;&nbsp;&nbsp;You don't want fine-grained control of the formatting of generated XML<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(3)</div>&nbsp;&nbsp;&nbsp;&nbsp;You would never use a hash key that was not a legal XML element name<br /><div id="podItem">&nbsp;&nbsp;&nbsp;&nbsp;*(4)</div>&nbsp;&nbsp;&nbsp;&nbsp;You don't need help converting between different encodings<br />In a serious XML project, you'll probably outgrow these assumptions fairly<br />quickly.  This section of the document used to offer some advice on chosing a<br />more powerful option.  That advice has now grown into the 'Perl-XML FAQ'<br />document which you can find at: <a href="#_pod_http://perl-xml.sourceforge.net/faq/">http://perl-xml.sourceforge.net/faq/</a><br />The advice in the FAQ boils down to a quick explanation of tree versus<br />event based parsers and then recommends:<br />For event based parsing, use SAX (do not set out to write any new code for <br />XML::Parser's handler API - it is obselete).<br />For tree-based parsing, you could choose between the 'Perlish' approach of<br /><a href="#_pod_XML::Twig">XML::Twig</a> and more standards based DOM implementations - preferably one with<br />XPath support.</div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_SEE ALSO" id="_pod_SEE ALSO"></a>SEE ALSO</td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea"><a href="Simple.html" target="urlWin" id="podUrl">XML::Simple</a> requires either <a href="#_pod_XML::Parser">XML::Parser</a> or <a href="#_pod_XML::SAX">XML::SAX</a>.<br />To generate documents with namespaces, <a href="#_pod_XML::NamespaceSupport">XML::NamespaceSupport</a> is required.<br />The optional caching functions require <a href="#_pod_Storable">Storable</a>.<br />Answers to Frequently Asked Questions about <B>XML::Simple</B> are bundled with this<br />distribution as: <a href="#_pod_XML::Simple::FAQ">XML::Simple::FAQ</a></div>
<div id="sep"></div>
<table id="genInfoTitle" width="100%"><tr><td><a name="_pod_COPYRIGHT " id="_pod_COPYRIGHT "></a>COPYRIGHT </td><td align="right"><a href="#TOP">Top</a></td></tr></table>
<div id="genInfoArea">Copyright 1999-2004 Grant McLean &lt;grantm@cpan.org&gt;<br />This library is free software; you can redistribute it and/or modify it<br />under the same terms as Perl itself.</div>
<div id="sep"></div>
</body>
</html>
